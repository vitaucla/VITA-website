<!DOCTYPE HTML>
<html class="staticrypt-html">
<head>
    <meta charset="utf-8">
    <title>Volunteers Only!</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <!-- Multi platform friendly favicon generated by https://realfavicongenerator.net/ -->
    <link rel="apple-touch-icon" sizes="180x180" href="images/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="images/favicon/favicon-16x16.png">
    <link rel="manifest" href="images/favicon/manifest.json">
    <link rel="mask-icon" href="images/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="shortcut icon" href="images/favicon/favicon.ico">
    <meta name="msapplication-config" content="images/favicon/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    <style>
        a {
            color: #3284bf;
        }

        .staticrypt-hr {
            margin-top: 20px;
            margin-bottom: 20px;
            border: 0;
            border-top: 1px solid #eee;
        }

        .staticrypt-page {
            width: 360px;
            padding: 8% 0 0;
            margin: auto;
            box-sizing: border-box;
        }

        .staticrypt-form {
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            max-width: 360px;
            margin: 0 auto 100px;
            padding: 45px;
            text-align: center;
            box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
        }

            .staticrypt-form input {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #00a5e5;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #FFFFFF;
                font-size: 14px;
                cursor: pointer;
            }

                .staticrypt-form .staticrypt-decrypt-button:hover,
                .staticrypt-form .staticrypt-decrypt-button:active,
                .staticrypt-form .staticrypt-decrypt-button:focus {
                    background: #00a5e5;
                }

        .staticrypt-html {
            height: 100%;
        }

        .staticrypt-body {
            margin-bottom: 1em;
            background: #3284BF; /* fallback for old browsers */
            background: -webkit-linear-gradient(right, #3284BF, #0055a6);
            background: -moz-linear-gradient(right, #3284BF, #0055a6);
            background: -o-linear-gradient(right, #3284BF, #0055a6);
            background: linear-gradient(to left, #3284BF, #0055a6);
            font-family: "Arial", sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        .staticrypt-instructions {
            margin-top: -1em;
            margin-bottom: 1em;
        }

        .staticrypt-title {
            font-size: 1.5em;
        }

        .staticrypt-footer {
            position: fixed;
            height: 20px;
            font-size: 16px;
            padding: 2px;
            bottom: 0;
            left: 0;
            right: 0;
            margin-bottom: 0;
        }

            .staticrypt-footer p {
                margin: 2px;
                text-align: center;
                float: right;
            }

            .staticrypt-footer a {
                text-decoration: none;
            }
    </style>
</head>
<body class="staticrypt-body">
    <div class="staticrypt-page">
        <div class="staticrypt-form">
            <div class="staticrypt-instructions">
                <p class="staticrypt-title">Volunteers Only!</p>
                <p>Check your welcome email for the password.</p>
            </div>
            <hr class="staticrypt-hr">
            <form id="staticrypt-form" action="#" method="post">
                <input id="staticrypt-password"
                       type="password"
                       name="password"
                       placeholder="Password"
                       autofocus />
                <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
            </form>
            <p>
                <a href="index.html">Back to main page...</a>
            </p>
        </div>
    </div>
    <script>

        ; (function (root, factory) {

            if (typeof exports === "object") {
                module.exports = exports = factory();
            }
            else if (typeof define === "function" && define.amd) {
                define([], factory);
            }
            else {
                root.CryptoJS = factory();
            }
        }(this, function () {

            var CryptoJS = CryptoJS || (function (Math, undefined) {

                var create = Object.create || (function () {
                    function F() { };

                    return function (obj) {
                        var subtype;

                        F.prototype = obj;

                        subtype = new F();

                        F.prototype = null;

                        return subtype;
                    };
                }())

                var C = {};

                var C_lib = C.lib = {};

                var Base = C_lib.Base = (function () {


                    return {

                        extend: function (overrides) {
                            var subtype = create(this);

                            if (overrides) {
                                subtype.mixIn(overrides);
                            }

                            if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                                subtype.init = function () {
                                    subtype.$super.init.apply(this, arguments);
                                };
                            }

                            subtype.init.prototype = subtype;

                            subtype.$super = this;

                            return subtype;
                        },

                        create: function () {
                            var instance = this.extend();
                            instance.init.apply(instance, arguments);

                            return instance;
                        },

                        init: function () {
                        },

                        mixIn: function (properties) {
                            for (var propertyName in properties) {
                                if (properties.hasOwnProperty(propertyName)) {
                                    this[propertyName] = properties[propertyName];
                                }
                            }

                            if (properties.hasOwnProperty('toString')) {
                                this.toString = properties.toString;
                            }
                        },

                        clone: function () {
                            return this.init.prototype.extend(this);
                        }
                    };
                }());

                var WordArray = C_lib.WordArray = Base.extend({

                    init: function (words, sigBytes) {
                        words = this.words = words || [];

                        if (sigBytes != undefined) {
                            this.sigBytes = sigBytes;
                        } else {
                            this.sigBytes = words.length * 4;
                        }
                    },

                    toString: function (encoder) {
                        return (encoder || Hex).stringify(this);
                    },

                    concat: function (wordArray) {

                        var thisWords = this.words;
                        var thatWords = wordArray.words;
                        var thisSigBytes = this.sigBytes;
                        var thatSigBytes = wordArray.sigBytes;

                        this.clamp();

                        if (thisSigBytes % 4) {
                            for (var i = 0; i < thatSigBytes; i++) {
                                var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                                thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
                            }
                        } else {
                            for (var i = 0; i < thatSigBytes; i += 4) {
                                thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
                            }
                        }
                        this.sigBytes += thatSigBytes;
                        return this;
                    },

                    clamp: function () {

                        var words = this.words;
                        var sigBytes = this.sigBytes;

                        words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
                        words.length = Math.ceil(sigBytes / 4);
                    },

                    clone: function () {
                        var clone = Base.clone.call(this);
                        clone.words = this.words.slice(0);

                        return clone;
                    },

                    random: function (nBytes) {
                        var words = [];

                        var r = (function (m_w) {
                            var m_w = m_w;
                            var m_z = 0x3ade68b1;
                            var mask = 0xffffffff;

                            return function () {
                                m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
                                m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
                                var result = ((m_z << 0x10) + m_w) & mask;
                                result /= 0x100000000;
                                result += 0.5;
                                return result * (Math.random() > .5 ? 1 : -1);
                            }
                        });

                        for (var i = 0, rcache; i < nBytes; i += 4) {
                            var _r = r((rcache || Math.random()) * 0x100000000);

                            rcache = _r() * 0x3ade67b7;
                            words.push((_r() * 0x100000000) | 0);
                        }

                        return new WordArray.init(words, nBytes);
                    }
                });

                var C_enc = C.enc = {};

                var Hex = C_enc.Hex = {

                    stringify: function (wordArray) {

                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;

                        var hexChars = [];
                        for (var i = 0; i < sigBytes; i++) {
                            var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                            hexChars.push((bite >>> 4).toString(16));
                            hexChars.push((bite & 0x0f).toString(16));
                        }

                        return hexChars.join('');
                    },

                    parse: function (hexStr) {

                        var hexStrLength = hexStr.length;

                        var words = [];
                        for (var i = 0; i < hexStrLength; i += 2) {
                            words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
                        }

                        return new WordArray.init(words, hexStrLength / 2);
                    }
                };

                var Latin1 = C_enc.Latin1 = {

                    stringify: function (wordArray) {

                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;

                        var latin1Chars = [];
                        for (var i = 0; i < sigBytes; i++) {
                            var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                            latin1Chars.push(String.fromCharCode(bite));
                        }
                        return latin1Chars.join('');
                    },

                    parse: function (latin1Str) {

                        var latin1StrLength = latin1Str.length;

                        var words = [];
                        for (var i = 0; i < latin1StrLength; i++) {
                            words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
                        }

                        return new WordArray.init(words, latin1StrLength);
                    }
                };

                var Utf8 = C_enc.Utf8 = {

                    stringify: function (wordArray) {
                        try {
                            return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                        } catch (e) {
                            throw new Error('Malformed UTF-8 data');
                        }
                    },

                    parse: function (utf8Str) {
                        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
                    }
                };

                var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({

                    reset: function () {
                        this._data = new WordArray.init();
                        this._nDataBytes = 0;
                    },

                    _append: function (data) {

                        if (typeof data == 'string') {
                            data = Utf8.parse(data);
                        }

                        this._data.concat(data);
                        this._nDataBytes += data.sigBytes;
                    },

                    _process: function (doFlush) {
                        var data = this._data;
                        var dataWords = data.words;
                        var dataSigBytes = data.sigBytes;
                        var blockSize = this.blockSize;
                        var blockSizeBytes = blockSize * 4;


                        var nBlocksReady = dataSigBytes / blockSizeBytes;
                        if (doFlush) {

                            nBlocksReady = Math.ceil(nBlocksReady);
                        } else {

                            nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                        }

                        var nWordsReady = nBlocksReady * blockSize;
                        var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                        if (nWordsReady) {
                            for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                                this._doProcessBlock(dataWords, offset);
                            }

                            var processedWords = dataWords.splice(0, nWordsReady);
                            data.sigBytes -= nBytesReady;
                        }

                        return new WordArray.init(processedWords, nBytesReady);
                    },

                    clone: function () {
                        var clone = Base.clone.call(this);
                        clone._data = this._data.clone();

                        return clone;
                    },

                    _minBufferSize: 0
                });

                var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({

                    cfg: Base.extend(),

                    init: function (cfg) {
                        this.cfg = this.cfg.extend(cfg);

                        this.reset();
                    },

                    reset: function () {
                        BufferedBlockAlgorithm.reset.call(this);

                        this._doReset();
                    },

                    update: function (messageUpdate) {

                        this._append(messageUpdate);
                        this._process();
                        return this;
                    },

                    finalize: function (messageUpdate) {
                        if (messageUpdate) {
                            this._append(messageUpdate);
                        }

                        var hash = this._doFinalize();

                        return hash;
                    },

                    blockSize: 512 / 32,

                    _createHelper: function (hasher) {
                        return function (message, cfg) {
                            return new hasher.init(cfg).finalize(message);
                        };
                    },

                    _createHmacHelper: function (hasher) {
                        return function (message, key) {
                            return new C_algo.HMAC.init(hasher, key).finalize(message);
                        };
                    }
                });

                var C_algo = C.algo = {};

                return C;
            }(Math));


            (function () {

                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var C_enc = C.enc;

                var Base64 = C_enc.Base64 = {

                    stringify: function (wordArray) {

                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;
                        var map = this._map;

                        wordArray.clamp();

                        var base64Chars = [];
                        for (var i = 0; i < sigBytes; i += 3) {
                            var byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
                            var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
                            var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

                            var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

                            for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
                                base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
                            }
                        }

                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                            while (base64Chars.length % 4) {
                                base64Chars.push(paddingChar);
                            }
                        }

                        return base64Chars.join('');
                    },

                    parse: function (base64Str) {

                        var base64StrLength = base64Str.length;
                        var map = this._map;
                        var reverseMap = this._reverseMap;

                        if (!reverseMap) {
                            reverseMap = this._reverseMap = [];
                            for (var j = 0; j < map.length; j++) {
                                reverseMap[map.charCodeAt(j)] = j;
                            }
                        }

                        var paddingChar = map.charAt(64);
                        if (paddingChar) {
                            var paddingIndex = base64Str.indexOf(paddingChar);
                            if (paddingIndex !== -1) {
                                base64StrLength = paddingIndex;
                            }
                        }

                        return parseLoop(base64Str, base64StrLength, reverseMap);

                    },

                    _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
                };

                function parseLoop(base64Str, base64StrLength, reverseMap) {
                    var words = [];
                    var nBytes = 0;
                    for (var i = 0; i < base64StrLength; i++) {
                        if (i % 4) {
                            var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
                            var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
                            words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
                            nBytes++;
                        }
                    }
                    return WordArray.create(words, nBytes);
                }
            }());

            (function (Math) {

                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;

                var T = [];

                (function () {
                    for (var i = 0; i < 64; i++) {
                        T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
                    }
                }());

                var MD5 = C_algo.MD5 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init([
                            0x67452301, 0xefcdab89,
                            0x98badcfe, 0x10325476
                        ]);
                    },

                    _doProcessBlock: function (M, offset) {

                        for (var i = 0; i < 16; i++) {

                            var offset_i = offset + i;
                            var M_offset_i = M[offset_i];

                            M[offset_i] = (
                                (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
                                (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
                            );
                        }

                        var H = this._hash.words;

                        var M_offset_0 = M[offset + 0];
                        var M_offset_1 = M[offset + 1];
                        var M_offset_2 = M[offset + 2];
                        var M_offset_3 = M[offset + 3];
                        var M_offset_4 = M[offset + 4];
                        var M_offset_5 = M[offset + 5];
                        var M_offset_6 = M[offset + 6];
                        var M_offset_7 = M[offset + 7];
                        var M_offset_8 = M[offset + 8];
                        var M_offset_9 = M[offset + 9];
                        var M_offset_10 = M[offset + 10];
                        var M_offset_11 = M[offset + 11];
                        var M_offset_12 = M[offset + 12];
                        var M_offset_13 = M[offset + 13];
                        var M_offset_14 = M[offset + 14];
                        var M_offset_15 = M[offset + 15];

                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];

                        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                        b = FF(b, c, d, a, M_offset_15, 22, T[15]);

                        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                        b = GG(b, c, d, a, M_offset_12, 20, T[31]);

                        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                        b = HH(b, c, d, a, M_offset_2, 23, T[47]);

                        a = II(a, b, c, d, M_offset_0, 6, T[48]);
                        d = II(d, a, b, c, M_offset_7, 10, T[49]);
                        c = II(c, d, a, b, M_offset_14, 15, T[50]);
                        b = II(b, c, d, a, M_offset_5, 21, T[51]);
                        a = II(a, b, c, d, M_offset_12, 6, T[52]);
                        d = II(d, a, b, c, M_offset_3, 10, T[53]);
                        c = II(c, d, a, b, M_offset_10, 15, T[54]);
                        b = II(b, c, d, a, M_offset_1, 21, T[55]);
                        a = II(a, b, c, d, M_offset_8, 6, T[56]);
                        d = II(d, a, b, c, M_offset_15, 10, T[57]);
                        c = II(c, d, a, b, M_offset_6, 15, T[58]);
                        b = II(b, c, d, a, M_offset_13, 21, T[59]);
                        a = II(a, b, c, d, M_offset_4, 6, T[60]);
                        d = II(d, a, b, c, M_offset_11, 10, T[61]);
                        c = II(c, d, a, b, M_offset_2, 15, T[62]);
                        b = II(b, c, d, a, M_offset_9, 21, T[63]);

                        H[0] = (H[0] + a) | 0;
                        H[1] = (H[1] + b) | 0;
                        H[2] = (H[2] + c) | 0;
                        H[3] = (H[3] + d) | 0;
                    },

                    _doFinalize: function () {
                        var data = this._data;
                        var dataWords = data.words;

                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;

                        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

                        var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                        var nBitsTotalL = nBitsTotal;
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
                            (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
                            (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)
                        );
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                            (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
                            (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)
                        );

                        data.sigBytes = (dataWords.length + 1) * 4;

                        this._process();

                        var hash = this._hash;
                        var H = hash.words;

                        for (var i = 0; i < 4; i++) {

                            var H_i = H[i];

                            H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
                                (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
                        }

                        return hash;
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();

                        return clone;
                    }
                });

                function FF(a, b, c, d, x, s, t) {
                    var n = a + ((b & c) | (~b & d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }

                function GG(a, b, c, d, x, s, t) {
                    var n = a + ((b & d) | (c & ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }

                function HH(a, b, c, d, x, s, t) {
                    var n = a + (b ^ c ^ d) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }

                function II(a, b, c, d, x, s, t) {
                    var n = a + (c ^ (b | ~d)) + x + t;
                    return ((n << s) | (n >>> (32 - s))) + b;
                }


                C.MD5 = Hasher._createHelper(MD5);

                C.HmacMD5 = Hasher._createHmacHelper(MD5);
            }(Math));


            (function () {

                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;

                var W = [];

                var SHA1 = C_algo.SHA1 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init([
                            0x67452301, 0xefcdab89,
                            0x98badcfe, 0x10325476,
                            0xc3d2e1f0
                        ]);
                    },

                    _doProcessBlock: function (M, offset) {

                        var H = this._hash.words;

                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        var e = H[4];

                        for (var i = 0; i < 80; i++) {
                            if (i < 16) {
                                W[i] = M[offset + i] | 0;
                            } else {
                                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                                W[i] = (n << 1) | (n >>> 31);
                            }

                            var t = ((a << 5) | (a >>> 27)) + e + W[i];
                            if (i < 20) {
                                t += ((b & c) | (~b & d)) + 0x5a827999;
                            } else if (i < 40) {
                                t += (b ^ c ^ d) + 0x6ed9eba1;
                            } else if (i < 60) {
                                t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
                            } else /* if (i < 80) */ {
                                t += (b ^ c ^ d) - 0x359d3e2a;
                            }

                            e = d;
                            d = c;
                            c = (b << 30) | (b >>> 2);
                            b = a;
                            a = t;
                        }

                        H[0] = (H[0] + a) | 0;
                        H[1] = (H[1] + b) | 0;
                        H[2] = (H[2] + c) | 0;
                        H[3] = (H[3] + d) | 0;
                        H[4] = (H[4] + e) | 0;
                    },

                    _doFinalize: function () {

                        var data = this._data;
                        var dataWords = data.words;

                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;

                        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;

                        this._process();

                        return this._hash;
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();

                        return clone;
                    }
                });

                C.SHA1 = Hasher._createHelper(SHA1);

                C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
            }());


            (function (Math) {

                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;

                var H = [];
                var K = [];

                (function () {
                    function isPrime(n) {
                        var sqrtN = Math.sqrt(n);
                        for (var factor = 2; factor <= sqrtN; factor++) {
                            if (!(n % factor)) {
                                return false;
                            }
                        }

                        return true;
                    }

                    function getFractionalBits(n) {
                        return ((n - (n | 0)) * 0x100000000) | 0;
                    }

                    var n = 2;
                    var nPrime = 0;
                    while (nPrime < 64) {
                        if (isPrime(n)) {
                            if (nPrime < 8) {
                                H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                            }
                            K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

                            nPrime++;
                        }

                        n++;
                    }
                }());

                var W = [];

                var SHA256 = C_algo.SHA256 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init(H.slice(0));
                    },

                    _doProcessBlock: function (M, offset) {

                        var H = this._hash.words;

                        // Working variables
                        var a = H[0];
                        var b = H[1];
                        var c = H[2];
                        var d = H[3];
                        var e = H[4];
                        var f = H[5];
                        var g = H[6];
                        var h = H[7];

                        // Computation
                        for (var i = 0; i < 64; i++) {
                            if (i < 16) {
                                W[i] = M[offset + i] | 0;
                            } else {
                                var gamma0x = W[i - 15];
                                var gamma0 = ((gamma0x << 25) | (gamma0x >>> 7)) ^
                                    ((gamma0x << 14) | (gamma0x >>> 18)) ^
                                    (gamma0x >>> 3);

                                var gamma1x = W[i - 2];
                                var gamma1 = ((gamma1x << 15) | (gamma1x >>> 17)) ^
                                    ((gamma1x << 13) | (gamma1x >>> 19)) ^
                                    (gamma1x >>> 10);

                                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                            }

                            var ch = (e & f) ^ (~e & g);
                            var maj = (a & b) ^ (a & c) ^ (b & c);

                            var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
                            var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25));

                            var t1 = h + sigma1 + ch + K[i] + W[i];
                            var t2 = sigma0 + maj;

                            h = g;
                            g = f;
                            f = e;
                            e = (d + t1) | 0;
                            d = c;
                            c = b;
                            b = a;
                            a = (t1 + t2) | 0;
                        }

                        // Intermediate hash value
                        H[0] = (H[0] + a) | 0;
                        H[1] = (H[1] + b) | 0;
                        H[2] = (H[2] + c) | 0;
                        H[3] = (H[3] + d) | 0;
                        H[4] = (H[4] + e) | 0;
                        H[5] = (H[5] + f) | 0;
                        H[6] = (H[6] + g) | 0;
                        H[7] = (H[7] + h) | 0;
                    },

                    _doFinalize: function () {
                        // Shortcuts
                        var data = this._data;
                        var dataWords = data.words;

                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;

                        // Add padding
                        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;

                        // Hash final blocks
                        this._process();

                        // Return final computed hash
                        return this._hash;
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();

                        return clone;
                    }
                });


                C.SHA256 = Hasher._createHelper(SHA256);

                C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
            }(Math));


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var C_enc = C.enc;

                var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {

                    stringify: function (wordArray) {
                        // Shortcuts
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;

                        // Convert
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                            var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
                            utf16Chars.push(String.fromCharCode(codePoint));
                        }

                        return utf16Chars.join('');
                    },

                    parse: function (utf16Str) {
                        // Shortcut
                        var utf16StrLength = utf16Str.length;

                        // Convert
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                            words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
                        }

                        return WordArray.create(words, utf16StrLength * 2);
                    }
                };

                C_enc.Utf16LE = {

                    stringify: function (wordArray) {
                        // Shortcuts
                        var words = wordArray.words;
                        var sigBytes = wordArray.sigBytes;

                        // Convert
                        var utf16Chars = [];
                        for (var i = 0; i < sigBytes; i += 2) {
                            var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
                            utf16Chars.push(String.fromCharCode(codePoint));
                        }

                        return utf16Chars.join('');
                    },

                    parse: function (utf16Str) {
                        // Shortcut
                        var utf16StrLength = utf16Str.length;

                        // Convert
                        var words = [];
                        for (var i = 0; i < utf16StrLength; i++) {
                            words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
                        }

                        return WordArray.create(words, utf16StrLength * 2);
                    }
                };

                function swapEndian(word) {
                    return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
                }
            }());


            (function () {
                // Check if typed arrays are supported
                if (typeof ArrayBuffer != 'function') {
                    return;
                }

                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;

                // Reference original init
                var superInit = WordArray.init;

                // Augment WordArray.init to handle typed arrays
                var subInit = WordArray.init = function (typedArray) {
                    // Convert buffers to uint8
                    if (typedArray instanceof ArrayBuffer) {
                        typedArray = new Uint8Array(typedArray);
                    }

                    // Convert other array views to uint8
                    if (
                        typedArray instanceof Int8Array ||
                        (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
                        typedArray instanceof Int16Array ||
                        typedArray instanceof Uint16Array ||
                        typedArray instanceof Int32Array ||
                        typedArray instanceof Uint32Array ||
                        typedArray instanceof Float32Array ||
                        typedArray instanceof Float64Array
                    ) {
                        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
                    }

                    // Handle Uint8Array
                    if (typedArray instanceof Uint8Array) {
                        // Shortcut
                        var typedArrayByteLength = typedArray.byteLength;

                        // Extract bytes
                        var words = [];
                        for (var i = 0; i < typedArrayByteLength; i++) {
                            words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
                        }

                        // Initialize this word array
                        superInit.call(this, words, typedArrayByteLength);
                    } else {
                        // Else call normal init
                        superInit.apply(this, arguments);
                    }
                };

                subInit.prototype = WordArray;
            }());

            (function (Math) {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_algo = C.algo;

                // Constants table
                var _zl = WordArray.create([
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                    7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                    3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                    1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                    4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
                var _zr = WordArray.create([
                    5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                    6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                    15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                    8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                    12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
                var _sl = WordArray.create([
                    11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                    7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                    11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                    11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                    9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
                var _sr = WordArray.create([
                    8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                    9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                    9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                    15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                    8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);

                var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
                var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

                /**
                 * RIPEMD160 hash algorithm.
                 */
                var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
                    _doReset: function () {
                        this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
                    },

                    _doProcessBlock: function (M, offset) {

                        // Swap endian
                        for (var i = 0; i < 16; i++) {
                            // Shortcuts
                            var offset_i = offset + i;
                            var M_offset_i = M[offset_i];

                            // Swap
                            M[offset_i] = (
                                (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
                                (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)
                            );
                        }
                        // Shortcut
                        var H = this._hash.words;
                        var hl = _hl.words;
                        var hr = _hr.words;
                        var zl = _zl.words;
                        var zr = _zr.words;
                        var sl = _sl.words;
                        var sr = _sr.words;

                        // Working variables
                        var al, bl, cl, dl, el;
                        var ar, br, cr, dr, er;

                        ar = al = H[0];
                        br = bl = H[1];
                        cr = cl = H[2];
                        dr = dl = H[3];
                        er = el = H[4];
                        // Computation
                        var t;
                        for (var i = 0; i < 80; i += 1) {
                            t = (al + M[offset + zl[i]]) | 0;
                            if (i < 16) {
                                t += f1(bl, cl, dl) + hl[0];
                            } else if (i < 32) {
                                t += f2(bl, cl, dl) + hl[1];
                            } else if (i < 48) {
                                t += f3(bl, cl, dl) + hl[2];
                            } else if (i < 64) {
                                t += f4(bl, cl, dl) + hl[3];
                            } else {// if (i<80) {
                                t += f5(bl, cl, dl) + hl[4];
                            }
                            t = t | 0;
                            t = rotl(t, sl[i]);
                            t = (t + el) | 0;
                            al = el;
                            el = dl;
                            dl = rotl(cl, 10);
                            cl = bl;
                            bl = t;

                            t = (ar + M[offset + zr[i]]) | 0;
                            if (i < 16) {
                                t += f5(br, cr, dr) + hr[0];
                            } else if (i < 32) {
                                t += f4(br, cr, dr) + hr[1];
                            } else if (i < 48) {
                                t += f3(br, cr, dr) + hr[2];
                            } else if (i < 64) {
                                t += f2(br, cr, dr) + hr[3];
                            } else {// if (i<80) {
                                t += f1(br, cr, dr) + hr[4];
                            }
                            t = t | 0;
                            t = rotl(t, sr[i]);
                            t = (t + er) | 0;
                            ar = er;
                            er = dr;
                            dr = rotl(cr, 10);
                            cr = br;
                            br = t;
                        }
                        // Intermediate hash value
                        t = (H[1] + cl + dr) | 0;
                        H[1] = (H[2] + dl + er) | 0;
                        H[2] = (H[3] + el + ar) | 0;
                        H[3] = (H[4] + al + br) | 0;
                        H[4] = (H[0] + bl + cr) | 0;
                        H[0] = t;
                    },

                    _doFinalize: function () {
                        // Shortcuts
                        var data = this._data;
                        var dataWords = data.words;

                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;

                        // Add padding
                        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                        dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
                            (((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                            (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00)
                        );
                        data.sigBytes = (dataWords.length + 1) * 4;

                        // Hash final blocks
                        this._process();

                        // Shortcuts
                        var hash = this._hash;
                        var H = hash.words;

                        // Swap endian
                        for (var i = 0; i < 5; i++) {
                            // Shortcut
                            var H_i = H[i];

                            // Swap
                            H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
                                (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
                        }

                        // Return final computed hash
                        return hash;
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();

                        return clone;
                    }
                });


                function f1(x, y, z) {
                    return ((x) ^ (y) ^ (z));

                }

                function f2(x, y, z) {
                    return (((x) & (y)) | ((~x) & (z)));
                }

                function f3(x, y, z) {
                    return (((x) | (~(y))) ^ (z));
                }

                function f4(x, y, z) {
                    return (((x) & (z)) | ((y) & (~(z))));
                }

                function f5(x, y, z) {
                    return ((x) ^ ((y) | (~(z))));

                }

                function rotl(x, n) {
                    return (x << n) | (x >>> (32 - n));
                }

                C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

                C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
            }(Math));


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Base = C_lib.Base;
                var C_enc = C.enc;
                var Utf8 = C_enc.Utf8;
                var C_algo = C.algo;

                /**
                 * HMAC algorithm.
                 */
                var HMAC = C_algo.HMAC = Base.extend({

                    init: function (hasher, key) {
                        // Init hasher
                        hasher = this._hasher = new hasher.init();

                        // Convert string to WordArray, else assume WordArray already
                        if (typeof key == 'string') {
                            key = Utf8.parse(key);
                        }

                        // Shortcuts
                        var hasherBlockSize = hasher.blockSize;
                        var hasherBlockSizeBytes = hasherBlockSize * 4;

                        // Allow arbitrary length keys
                        if (key.sigBytes > hasherBlockSizeBytes) {
                            key = hasher.finalize(key);
                        }

                        // Clamp excess bits
                        key.clamp();

                        // Clone key for inner and outer pads
                        var oKey = this._oKey = key.clone();
                        var iKey = this._iKey = key.clone();

                        // Shortcuts
                        var oKeyWords = oKey.words;
                        var iKeyWords = iKey.words;

                        // XOR keys with pad constants
                        for (var i = 0; i < hasherBlockSize; i++) {
                            oKeyWords[i] ^= 0x5c5c5c5c;
                            iKeyWords[i] ^= 0x36363636;
                        }
                        oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

                        // Set initial values
                        this.reset();
                    },

                    reset: function () {
                        // Shortcut
                        var hasher = this._hasher;

                        // Reset
                        hasher.reset();
                        hasher.update(this._iKey);
                    },

                    update: function (messageUpdate) {
                        this._hasher.update(messageUpdate);

                        // Chainable
                        return this;
                    },

                    finalize: function (messageUpdate) {
                        // Shortcut
                        var hasher = this._hasher;

                        var innerHash = hasher.finalize(messageUpdate);
                        hasher.reset();
                        var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

                        return hmac;
                    }
                });
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Base = C_lib.Base;
                var WordArray = C_lib.WordArray;
                var C_algo = C.algo;
                var SHA1 = C_algo.SHA1;
                var HMAC = C_algo.HMAC;

                /**
                 * Password-Based Key Derivation Function 2 algorithm.
                 */
                var PBKDF2 = C_algo.PBKDF2 = Base.extend({

                    cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: SHA1,
                        iterations: 1
                    }),

                    init: function (cfg) {
                        this.cfg = this.cfg.extend(cfg);
                    },

                    compute: function (password, salt) {
                        // Shortcut
                        var cfg = this.cfg;

                        // Init HMAC
                        var hmac = HMAC.create(cfg.hasher, password);

                        // Initial values
                        var derivedKey = WordArray.create();
                        var blockIndex = WordArray.create([0x00000001]);

                        // Shortcuts
                        var derivedKeyWords = derivedKey.words;
                        var blockIndexWords = blockIndex.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;

                        // Generate key
                        while (derivedKeyWords.length < keySize) {
                            var block = hmac.update(salt).finalize(blockIndex);
                            hmac.reset();

                            // Shortcuts
                            var blockWords = block.words;
                            var blockWordsLength = blockWords.length;

                            // Iterations
                            var intermediate = block;
                            for (var i = 1; i < iterations; i++) {
                                intermediate = hmac.finalize(intermediate);
                                hmac.reset();

                                // Shortcut
                                var intermediateWords = intermediate.words;

                                // XOR intermediate with block
                                for (var j = 0; j < blockWordsLength; j++) {
                                    blockWords[j] ^= intermediateWords[j];
                                }
                            }

                            derivedKey.concat(block);
                            blockIndexWords[0]++;
                        }
                        derivedKey.sigBytes = keySize * 4;

                        return derivedKey;
                    }
                });

                C.PBKDF2 = function (password, salt, cfg) {
                    return PBKDF2.create(cfg).compute(password, salt);
                };
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Base = C_lib.Base;
                var WordArray = C_lib.WordArray;
                var C_algo = C.algo;
                var MD5 = C_algo.MD5;

                var EvpKDF = C_algo.EvpKDF = Base.extend({

                    cfg: Base.extend({
                        keySize: 128 / 32,
                        hasher: MD5,
                        iterations: 1
                    }),

                    init: function (cfg) {
                        this.cfg = this.cfg.extend(cfg);
                    },

                    compute: function (password, salt) {
                        // Shortcut
                        var cfg = this.cfg;

                        // Init hasher
                        var hasher = cfg.hasher.create();

                        // Initial values
                        var derivedKey = WordArray.create();

                        // Shortcuts
                        var derivedKeyWords = derivedKey.words;
                        var keySize = cfg.keySize;
                        var iterations = cfg.iterations;

                        // Generate key
                        while (derivedKeyWords.length < keySize) {
                            if (block) {
                                hasher.update(block);
                            }
                            var block = hasher.update(password).finalize(salt);
                            hasher.reset();

                            // Iterations
                            for (var i = 1; i < iterations; i++) {
                                block = hasher.finalize(block);
                                hasher.reset();
                            }

                            derivedKey.concat(block);
                        }
                        derivedKey.sigBytes = keySize * 4;

                        return derivedKey;
                    }
                });

                C.EvpKDF = function (password, salt, cfg) {
                    return EvpKDF.create(cfg).compute(password, salt);
                };
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var C_algo = C.algo;
                var SHA256 = C_algo.SHA256;

                /**
                 * SHA-224 hash algorithm.
                 */
                var SHA224 = C_algo.SHA224 = SHA256.extend({
                    _doReset: function () {
                        this._hash = new WordArray.init([
                            0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
                            0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
                        ]);
                    },

                    _doFinalize: function () {
                        var hash = SHA256._doFinalize.call(this);

                        hash.sigBytes -= 4;

                        return hash;
                    }
                });

                C.SHA224 = SHA256._createHelper(SHA224);
                C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
            }());


            (function (undefined) {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Base = C_lib.Base;
                var X32WordArray = C_lib.WordArray;

                var C_x64 = C.x64 = {};

                var X64Word = C_x64.Word = Base.extend({

                    init: function (high, low) {
                        this.high = high;
                        this.low = low;
                    }

                });

                var X64WordArray = C_x64.WordArray = Base.extend({

                    init: function (words, sigBytes) {
                        words = this.words = words || [];

                        if (sigBytes != undefined) {
                            this.sigBytes = sigBytes;
                        } else {
                            this.sigBytes = words.length * 8;
                        }
                    },

                    toX32: function () {
                        // Shortcuts
                        var x64Words = this.words;
                        var x64WordsLength = x64Words.length;

                        // Convert
                        var x32Words = [];
                        for (var i = 0; i < x64WordsLength; i++) {
                            var x64Word = x64Words[i];
                            x32Words.push(x64Word.high);
                            x32Words.push(x64Word.low);
                        }

                        return X32WordArray.create(x32Words, this.sigBytes);
                    },


                    clone: function () {
                        var clone = Base.clone.call(this);

                        // Clone "words" array
                        var words = clone.words = this.words.slice(0);

                        // Clone each X64Word object
                        var wordsLength = words.length;
                        for (var i = 0; i < wordsLength; i++) {
                            words[i] = words[i].clone();
                        }

                        return clone;
                    }
                });
            }());


            (function (Math) {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var Hasher = C_lib.Hasher;
                var C_x64 = C.x64;
                var X64Word = C_x64.Word;
                var C_algo = C.algo;

                // Constants tables
                var RHO_OFFSETS = [];
                var PI_INDEXES = [];
                var ROUND_CONSTANTS = [];

                // Compute Constants
                (function () {
                    // Compute rho offset constants
                    var x = 1, y = 0;
                    for (var t = 0; t < 24; t++) {
                        RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

                        var newX = y % 5;
                        var newY = (2 * x + 3 * y) % 5;
                        x = newX;
                        y = newY;
                    }

                    // Compute pi index constants
                    for (var x = 0; x < 5; x++) {
                        for (var y = 0; y < 5; y++) {
                            PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
                        }
                    }

                    // Compute round constants
                    var LFSR = 0x01;
                    for (var i = 0; i < 24; i++) {
                        var roundConstantMsw = 0;
                        var roundConstantLsw = 0;

                        for (var j = 0; j < 7; j++) {
                            if (LFSR & 0x01) {
                                var bitPosition = (1 << j) - 1;
                                if (bitPosition < 32) {
                                    roundConstantLsw ^= 1 << bitPosition;
                                } else /* if (bitPosition >= 32) */ {
                                    roundConstantMsw ^= 1 << (bitPosition - 32);
                                }
                            }

                            // Compute next LFSR
                            if (LFSR & 0x80) {
                                // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
                                LFSR = (LFSR << 1) ^ 0x71;
                            } else {
                                LFSR <<= 1;
                            }
                        }

                        ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
                    }
                }());

                var T = [];
                (function () {
                    for (var i = 0; i < 25; i++) {
                        T[i] = X64Word.create();
                    }
                }());

                var SHA3 = C_algo.SHA3 = Hasher.extend({

                    cfg: Hasher.cfg.extend({
                        outputLength: 512
                    }),

                    _doReset: function () {
                        var state = this._state = []
                        for (var i = 0; i < 25; i++) {
                            state[i] = new X64Word.init();
                        }

                        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
                    },

                    _doProcessBlock: function (M, offset) {

                        var state = this._state;
                        var nBlockSizeLanes = this.blockSize / 2;

                        for (var i = 0; i < nBlockSizeLanes; i++) {
                            // Shortcuts
                            var M2i = M[offset + 2 * i];
                            var M2i1 = M[offset + 2 * i + 1];

                            // Swap endian
                            M2i = (
                                (((M2i << 8) | (M2i >>> 24)) & 0x00ff00ff) |
                                (((M2i << 24) | (M2i >>> 8)) & 0xff00ff00)
                            );
                            M2i1 = (
                                (((M2i1 << 8) | (M2i1 >>> 24)) & 0x00ff00ff) |
                                (((M2i1 << 24) | (M2i1 >>> 8)) & 0xff00ff00)
                            );

                            var lane = state[i];
                            lane.high ^= M2i1;
                            lane.low ^= M2i;
                        }

                        // Rounds
                        for (var round = 0; round < 24; round++) {
                            // Theta
                            for (var x = 0; x < 5; x++) {
                                // Mix column lanes
                                var tMsw = 0, tLsw = 0;
                                for (var y = 0; y < 5; y++) {
                                    var lane = state[x + 5 * y];
                                    tMsw ^= lane.high;
                                    tLsw ^= lane.low;
                                }

                                // Temporary values
                                var Tx = T[x];
                                Tx.high = tMsw;
                                Tx.low = tLsw;
                            }
                            for (var x = 0; x < 5; x++) {
                                // Shortcuts
                                var Tx4 = T[(x + 4) % 5];
                                var Tx1 = T[(x + 1) % 5];
                                var Tx1Msw = Tx1.high;
                                var Tx1Lsw = Tx1.low;

                                // Mix surrounding columns
                                var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
                                var tLsw = Tx4.low ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
                                for (var y = 0; y < 5; y++) {
                                    var lane = state[x + 5 * y];
                                    lane.high ^= tMsw;
                                    lane.low ^= tLsw;
                                }
                            }

                            // Rho Pi
                            for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                                // Shortcuts
                                var lane = state[laneIndex];
                                var laneMsw = lane.high;
                                var laneLsw = lane.low;
                                var rhoOffset = RHO_OFFSETS[laneIndex];

                                // Rotate lanes
                                if (rhoOffset < 32) {
                                    var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
                                    var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
                                } else /* if (rhoOffset >= 32) */ {
                                    var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
                                    var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
                                }

                                // Transpose lanes
                                var TPiLane = T[PI_INDEXES[laneIndex]];
                                TPiLane.high = tMsw;
                                TPiLane.low = tLsw;
                            }

                            // Rho pi at x = y = 0
                            var T0 = T[0];
                            var state0 = state[0];
                            T0.high = state0.high;
                            T0.low = state0.low;

                            // Chi
                            for (var x = 0; x < 5; x++) {
                                for (var y = 0; y < 5; y++) {
                                    // Shortcuts
                                    var laneIndex = x + 5 * y;
                                    var lane = state[laneIndex];
                                    var TLane = T[laneIndex];
                                    var Tx1Lane = T[((x + 1) % 5) + 5 * y];
                                    var Tx2Lane = T[((x + 2) % 5) + 5 * y];

                                    // Mix rows
                                    lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
                                    lane.low = TLane.low ^ (~Tx1Lane.low & Tx2Lane.low);
                                }
                            }

                            // Iota
                            var lane = state[0];
                            var roundConstant = ROUND_CONSTANTS[round];
                            lane.high ^= roundConstant.high;
                            lane.low ^= roundConstant.low;;
                        }
                    },

                    _doFinalize: function () {
                        // Shortcuts
                        var data = this._data;
                        var dataWords = data.words;
                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;
                        var blockSizeBits = this.blockSize * 32;

                        // Add padding
                        dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
                        dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
                        data.sigBytes = dataWords.length * 4;

                        // Hash final blocks
                        this._process();

                        // Shortcuts
                        var state = this._state;
                        var outputLengthBytes = this.cfg.outputLength / 8;
                        var outputLengthLanes = outputLengthBytes / 8;

                        // Squeeze
                        var hashWords = [];
                        for (var i = 0; i < outputLengthLanes; i++) {
                            // Shortcuts
                            var lane = state[i];
                            var laneMsw = lane.high;
                            var laneLsw = lane.low;

                            // Swap endian
                            laneMsw = (
                                (((laneMsw << 8) | (laneMsw >>> 24)) & 0x00ff00ff) |
                                (((laneMsw << 24) | (laneMsw >>> 8)) & 0xff00ff00)
                            );
                            laneLsw = (
                                (((laneLsw << 8) | (laneLsw >>> 24)) & 0x00ff00ff) |
                                (((laneLsw << 24) | (laneLsw >>> 8)) & 0xff00ff00)
                            );

                            // Squeeze state to retrieve hash
                            hashWords.push(laneLsw);
                            hashWords.push(laneMsw);
                        }

                        // Return final computed hash
                        return new WordArray.init(hashWords, outputLengthBytes);
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);

                        var state = clone._state = this._state.slice(0);
                        for (var i = 0; i < 25; i++) {
                            state[i] = state[i].clone();
                        }

                        return clone;
                    }
                });

                C.SHA3 = Hasher._createHelper(SHA3);
                C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
            }(Math));


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Hasher = C_lib.Hasher;
                var C_x64 = C.x64;
                var X64Word = C_x64.Word;
                var X64WordArray = C_x64.WordArray;
                var C_algo = C.algo;

                function X64Word_create() {
                    return X64Word.create.apply(X64Word, arguments);
                }

                // Constants
                var K = [
                    X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
                    X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
                    X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
                    X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
                    X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
                    X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
                    X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
                    X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
                    X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
                    X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
                    X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
                    X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
                    X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
                    X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
                    X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
                    X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
                    X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
                    X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
                    X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
                    X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
                    X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
                    X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
                    X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
                    X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
                    X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
                    X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
                    X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
                    X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
                    X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
                    X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
                    X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
                    X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
                    X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
                    X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
                    X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
                    X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
                    X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
                    X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
                    X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
                    X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
                ];

                // Reusable objects
                var W = [];
                (function () {
                    for (var i = 0; i < 80; i++) {
                        W[i] = X64Word_create();
                    }
                }());

                /**
                 * SHA-512 hash algorithm.
                 */
                var SHA512 = C_algo.SHA512 = Hasher.extend({
                    _doReset: function () {
                        this._hash = new X64WordArray.init([
                            new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
                            new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
                            new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
                            new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
                        ]);
                    },

                    _doProcessBlock: function (M, offset) {
                        // Shortcuts
                        var H = this._hash.words;

                        var H0 = H[0];
                        var H1 = H[1];
                        var H2 = H[2];
                        var H3 = H[3];
                        var H4 = H[4];
                        var H5 = H[5];
                        var H6 = H[6];
                        var H7 = H[7];

                        var H0h = H0.high;
                        var H0l = H0.low;
                        var H1h = H1.high;
                        var H1l = H1.low;
                        var H2h = H2.high;
                        var H2l = H2.low;
                        var H3h = H3.high;
                        var H3l = H3.low;
                        var H4h = H4.high;
                        var H4l = H4.low;
                        var H5h = H5.high;
                        var H5l = H5.low;
                        var H6h = H6.high;
                        var H6l = H6.low;
                        var H7h = H7.high;
                        var H7l = H7.low;

                        // Working variables
                        var ah = H0h;
                        var al = H0l;
                        var bh = H1h;
                        var bl = H1l;
                        var ch = H2h;
                        var cl = H2l;
                        var dh = H3h;
                        var dl = H3l;
                        var eh = H4h;
                        var el = H4l;
                        var fh = H5h;
                        var fl = H5l;
                        var gh = H6h;
                        var gl = H6l;
                        var hh = H7h;
                        var hl = H7l;

                        // Rounds
                        for (var i = 0; i < 80; i++) {
                            // Shortcut
                            var Wi = W[i];

                            // Extend message
                            if (i < 16) {
                                var Wih = Wi.high = M[offset + i * 2] | 0;
                                var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                            } else {
                                // Gamma0
                                var gamma0x = W[i - 15];
                                var gamma0xh = gamma0x.high;
                                var gamma0xl = gamma0x.low;
                                var gamma0h = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
                                var gamma0l = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

                                // Gamma1
                                var gamma1x = W[i - 2];
                                var gamma1xh = gamma1x.high;
                                var gamma1xl = gamma1x.low;
                                var gamma1h = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
                                var gamma1l = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

                                // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                                var Wi7 = W[i - 7];
                                var Wi7h = Wi7.high;
                                var Wi7l = Wi7.low;

                                var Wi16 = W[i - 16];
                                var Wi16h = Wi16.high;
                                var Wi16l = Wi16.low;

                                var Wil = gamma0l + Wi7l;
                                var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
                                var Wil = Wil + gamma1l;
                                var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
                                var Wil = Wil + Wi16l;
                                var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

                                Wi.high = Wih;
                                Wi.low = Wil;
                            }

                            var chh = (eh & fh) ^ (~eh & gh);
                            var chl = (el & fl) ^ (~el & gl);
                            var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
                            var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

                            var sigma0h = ((ah >>> 28) | (al << 4)) ^ ((ah << 30) | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
                            var sigma0l = ((al >>> 28) | (ah << 4)) ^ ((al << 30) | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
                            var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
                            var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

                            // t1 = h + sigma1 + ch + K[i] + W[i]
                            var Ki = K[i];
                            var Kih = Ki.high;
                            var Kil = Ki.low;

                            var t1l = hl + sigma1l;
                            var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
                            var t1l = t1l + chl;
                            var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
                            var t1l = t1l + Kil;
                            var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
                            var t1l = t1l + Wil;
                            var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

                            // t2 = sigma0 + maj
                            var t2l = sigma0l + majl;
                            var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

                            // Update working variables
                            hh = gh;
                            hl = gl;
                            gh = fh;
                            gl = fl;
                            fh = eh;
                            fl = el;
                            el = (dl + t1l) | 0;
                            eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
                            dh = ch;
                            dl = cl;
                            ch = bh;
                            cl = bl;
                            bh = ah;
                            bl = al;
                            al = (t1l + t2l) | 0;
                            ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
                        }

                        // Intermediate hash value
                        H0l = H0.low = (H0l + al);
                        H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
                        H1l = H1.low = (H1l + bl);
                        H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
                        H2l = H2.low = (H2l + cl);
                        H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
                        H3l = H3.low = (H3l + dl);
                        H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
                        H4l = H4.low = (H4l + el);
                        H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
                        H5l = H5.low = (H5l + fl);
                        H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
                        H6l = H6.low = (H6l + gl);
                        H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
                        H7l = H7.low = (H7l + hl);
                        H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
                    },

                    _doFinalize: function () {
                        // Shortcuts
                        var data = this._data;
                        var dataWords = data.words;

                        var nBitsTotal = this._nDataBytes * 8;
                        var nBitsLeft = data.sigBytes * 8;

                        // Add padding
                        dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
                        dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
                        data.sigBytes = dataWords.length * 4;

                        // Hash final blocks
                        this._process();

                        // Convert hash to 32-bit word array before returning
                        var hash = this._hash.toX32();

                        // Return final computed hash
                        return hash;
                    },

                    clone: function () {
                        var clone = Hasher.clone.call(this);
                        clone._hash = this._hash.clone();

                        return clone;
                    },

                    blockSize: 1024 / 32
                });

                C.SHA512 = Hasher._createHelper(SHA512);

                C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_x64 = C.x64;
                var X64Word = C_x64.Word;
                var X64WordArray = C_x64.WordArray;
                var C_algo = C.algo;
                var SHA512 = C_algo.SHA512;

                /**
                 * SHA-384 hash algorithm.
                 */
                var SHA384 = C_algo.SHA384 = SHA512.extend({
                    _doReset: function () {
                        this._hash = new X64WordArray.init([
                            new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
                            new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
                            new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
                            new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
                        ]);
                    },

                    _doFinalize: function () {
                        var hash = SHA512._doFinalize.call(this);

                        hash.sigBytes -= 16;

                        return hash;
                    }
                });

                C.SHA384 = SHA512._createHelper(SHA384);

                C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
            }());


            CryptoJS.lib.Cipher || (function (undefined) {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var Base = C_lib.Base;
                var WordArray = C_lib.WordArray;
                var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
                var C_enc = C.enc;
                var Utf8 = C_enc.Utf8;
                var Base64 = C_enc.Base64;
                var C_algo = C.algo;
                var EvpKDF = C_algo.EvpKDF;

                var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({

                    cfg: Base.extend(),

                    createEncryptor: function (key, cfg) {
                        return this.create(this._ENC_XFORM_MODE, key, cfg);
                    },

                    createDecryptor: function (key, cfg) {
                        return this.create(this._DEC_XFORM_MODE, key, cfg);
                    },

                    init: function (xformMode, key, cfg) {
                        // Apply config defaults
                        this.cfg = this.cfg.extend(cfg);

                        // Store transform mode and key
                        this._xformMode = xformMode;
                        this._key = key;

                        // Set initial values
                        this.reset();
                    },

                    reset: function () {
                        // Reset data buffer
                        BufferedBlockAlgorithm.reset.call(this);

                        // Perform concrete-cipher logic
                        this._doReset();
                    },

                    process: function (dataUpdate) {
                        // Append
                        this._append(dataUpdate);

                        // Process available blocks
                        return this._process();
                    },

                    finalize: function (dataUpdate) {
                        // Final data update
                        if (dataUpdate) {
                            this._append(dataUpdate);
                        }

                        // Perform concrete-cipher logic
                        var finalProcessedData = this._doFinalize();

                        return finalProcessedData;
                    },

                    keySize: 128 / 32,

                    ivSize: 128 / 32,

                    _ENC_XFORM_MODE: 1,

                    _DEC_XFORM_MODE: 2,

                    _createHelper: (function () {
                        function selectCipherStrategy(key) {
                            if (typeof key == 'string') {
                                return PasswordBasedCipher;
                            } else {
                                return SerializableCipher;
                            }
                        }

                        return function (cipher) {
                            return {
                                encrypt: function (message, key, cfg) {
                                    return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                                },

                                decrypt: function (ciphertext, key, cfg) {
                                    return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                                }
                            };
                        };
                    }())
                });


                var StreamCipher = C_lib.StreamCipher = Cipher.extend({
                    _doFinalize: function () {
                        // Process partial blocks
                        var finalProcessedBlocks = this._process(!!'flush');

                        return finalProcessedBlocks;
                    },

                    blockSize: 1
                });

                /**
                 * Mode namespace.
                 */
                var C_mode = C.mode = {};

                /**
                 * Abstract base block cipher mode template.
                 */
                var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
                    /**
                     * Creates this mode for encryption.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
                     */
                    createEncryptor: function (cipher, iv) {
                        return this.Encryptor.create(cipher, iv);
                    },

                    /**
                     * Creates this mode for decryption.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
                     */
                    createDecryptor: function (cipher, iv) {
                        return this.Decryptor.create(cipher, iv);
                    },

                    /**
                     * Initializes a newly created mode.
                     *
                     * @param {Cipher} cipher A block cipher instance.
                     * @param {Array} iv The IV words.
                     *
                     * @example
                     *
                     *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
                     */
                    init: function (cipher, iv) {
                        this._cipher = cipher;
                        this._iv = iv;
                    }
                });

                /**
                 * Cipher Block Chaining mode.
                 */
                var CBC = C_mode.CBC = (function () {
                    /**
                     * Abstract base CBC mode.
                     */
                    var CBC = BlockCipherMode.extend();

                    /**
                     * CBC encryptor.
                     */
                    CBC.Encryptor = CBC.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function (words, offset) {
                            // Shortcuts
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;

                            // XOR and encrypt
                            xorBlock.call(this, words, offset, blockSize);
                            cipher.encryptBlock(words, offset);

                            // Remember this block to use with next block
                            this._prevBlock = words.slice(offset, offset + blockSize);
                        }
                    });

                    /**
                     * CBC decryptor.
                     */
                    CBC.Decryptor = CBC.extend({
                        /**
                         * Processes the data block at offset.
                         *
                         * @param {Array} words The data words to operate on.
                         * @param {number} offset The offset where the block starts.
                         *
                         * @example
                         *
                         *     mode.processBlock(data.words, offset);
                         */
                        processBlock: function (words, offset) {
                            // Shortcuts
                            var cipher = this._cipher;
                            var blockSize = cipher.blockSize;

                            // Remember this block to use with next block
                            var thisBlock = words.slice(offset, offset + blockSize);

                            // Decrypt and XOR
                            cipher.decryptBlock(words, offset);
                            xorBlock.call(this, words, offset, blockSize);

                            // This block becomes the previous block
                            this._prevBlock = thisBlock;
                        }
                    });

                    function xorBlock(words, offset, blockSize) {
                        // Shortcut
                        var iv = this._iv;

                        // Choose mixing block
                        if (iv) {
                            var block = iv;

                            // Remove IV for subsequent blocks
                            this._iv = undefined;
                        } else {
                            var block = this._prevBlock;
                        }

                        // XOR blocks
                        for (var i = 0; i < blockSize; i++) {
                            words[offset + i] ^= block[i];
                        }
                    }

                    return CBC;
                }());

                /**
                 * Padding namespace.
                 */
                var C_pad = C.pad = {};

                /**
                 * PKCS #5/7 padding strategy.
                 */
                var Pkcs7 = C_pad.Pkcs7 = {
                    /**
                     * Pads data using the algorithm defined in PKCS #5/7.
                     *
                     * @param {WordArray} data The data to pad.
                     * @param {number} blockSize The multiple that the data should be padded to.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
                     */
                    pad: function (data, blockSize) {
                        // Shortcut
                        var blockSizeBytes = blockSize * 4;

                        // Count padding bytes
                        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

                        // Create padding word
                        var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

                        // Create padding
                        var paddingWords = [];
                        for (var i = 0; i < nPaddingBytes; i += 4) {
                            paddingWords.push(paddingWord);
                        }
                        var padding = WordArray.create(paddingWords, nPaddingBytes);

                        // Add padding
                        data.concat(padding);
                    },

                    /**
                     * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
                     *
                     * @param {WordArray} data The data to unpad.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     CryptoJS.pad.Pkcs7.unpad(wordArray);
                     */
                    unpad: function (data) {
                        // Get number of padding bytes from last byte
                        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

                        // Remove padding
                        data.sigBytes -= nPaddingBytes;
                    }
                };

                /**
                 * Abstract base block cipher template.
                 *
                 * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
                 */
                var BlockCipher = C_lib.BlockCipher = Cipher.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {Mode} mode The block mode to use. Default: CBC
                     * @property {Padding} padding The padding strategy to use. Default: Pkcs7
                     */
                    cfg: Cipher.cfg.extend({
                        mode: CBC,
                        padding: Pkcs7
                    }),

                    reset: function () {
                        // Reset cipher
                        Cipher.reset.call(this);

                        // Shortcuts
                        var cfg = this.cfg;
                        var iv = cfg.iv;
                        var mode = cfg.mode;

                        // Reset block mode
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                            var modeCreator = mode.createEncryptor;
                        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                            var modeCreator = mode.createDecryptor;
                            // Keep at least one block in the buffer for unpadding
                            this._minBufferSize = 1;
                        }

                        if (this._mode && this._mode.__creator == modeCreator) {
                            this._mode.init(this, iv && iv.words);
                        } else {
                            this._mode = modeCreator.call(mode, this, iv && iv.words);
                            this._mode.__creator = modeCreator;
                        }
                    },

                    _doProcessBlock: function (words, offset) {
                        this._mode.processBlock(words, offset);
                    },

                    _doFinalize: function () {
                        // Shortcut
                        var padding = this.cfg.padding;

                        // Finalize
                        if (this._xformMode == this._ENC_XFORM_MODE) {
                            // Pad data
                            padding.pad(this._data, this.blockSize);

                            // Process final blocks
                            var finalProcessedBlocks = this._process(!!'flush');
                        } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
                            // Process final blocks
                            var finalProcessedBlocks = this._process(!!'flush');

                            // Unpad data
                            padding.unpad(finalProcessedBlocks);
                        }

                        return finalProcessedBlocks;
                    },

                    blockSize: 128 / 32
                });

                /**
                 * A collection of cipher parameters.
                 *
                 * @property {WordArray} ciphertext The raw ciphertext.
                 * @property {WordArray} key The key to this ciphertext.
                 * @property {WordArray} iv The IV used in the ciphering operation.
                 * @property {WordArray} salt The salt used with a key derivation function.
                 * @property {Cipher} algorithm The cipher algorithm.
                 * @property {Mode} mode The block mode used in the ciphering operation.
                 * @property {Padding} padding The padding scheme used in the ciphering operation.
                 * @property {number} blockSize The block size of the cipher.
                 * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
                 */
                var CipherParams = C_lib.CipherParams = Base.extend({
                    /**
                     * Initializes a newly created cipher params object.
                     *
                     * @param {Object} cipherParams An object with any of the possible cipher parameters.
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.lib.CipherParams.create({
                     *         ciphertext: ciphertextWordArray,
                     *         key: keyWordArray,
                     *         iv: ivWordArray,
                     *         salt: saltWordArray,
                     *         algorithm: CryptoJS.algo.AES,
                     *         mode: CryptoJS.mode.CBC,
                     *         padding: CryptoJS.pad.PKCS7,
                     *         blockSize: 4,
                     *         formatter: CryptoJS.format.OpenSSL
                     *     });
                     */
                    init: function (cipherParams) {
                        this.mixIn(cipherParams);
                    },

                    /**
                     * Converts this cipher params object to a string.
                     *
                     * @param {Format} formatter (Optional) The formatting strategy to use.
                     *
                     * @return {string} The stringified cipher params.
                     *
                     * @throws Error If neither the formatter nor the default formatter is set.
                     *
                     * @example
                     *
                     *     var string = cipherParams + '';
                     *     var string = cipherParams.toString();
                     *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
                     */
                    toString: function (formatter) {
                        return (formatter || this.formatter).stringify(this);
                    }
                });

                /**
                 * Format namespace.
                 */
                var C_format = C.format = {};

                /**
                 * OpenSSL formatting strategy.
                 */
                var OpenSSLFormatter = C_format.OpenSSL = {
                    /**
                     * Converts a cipher params object to an OpenSSL-compatible string.
                     *
                     * @param {CipherParams} cipherParams The cipher params object.
                     *
                     * @return {string} The OpenSSL-compatible string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
                     */
                    stringify: function (cipherParams) {
                        // Shortcuts
                        var ciphertext = cipherParams.ciphertext;
                        var salt = cipherParams.salt;

                        // Format
                        if (salt) {
                            var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
                        } else {
                            var wordArray = ciphertext;
                        }

                        return wordArray.toString(Base64);
                    },

                    /**
                     * Converts an OpenSSL-compatible string to a cipher params object.
                     *
                     * @param {string} openSSLStr The OpenSSL-compatible string.
                     *
                     * @return {CipherParams} The cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
                     */
                    parse: function (openSSLStr) {
                        // Parse base64
                        var ciphertext = Base64.parse(openSSLStr);

                        // Shortcut
                        var ciphertextWords = ciphertext.words;

                        // Test for salt
                        if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                            // Extract salt
                            var salt = WordArray.create(ciphertextWords.slice(2, 4));

                            // Remove salt from ciphertext
                            ciphertextWords.splice(0, 4);
                            ciphertext.sigBytes -= 16;
                        }

                        return CipherParams.create({ ciphertext: ciphertext, salt: salt });
                    }
                };

                /**
                 * A cipher wrapper that returns ciphertext as a serializable cipher params object.
                 */
                var SerializableCipher = C_lib.SerializableCipher = Base.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
                     */
                    cfg: Base.extend({
                        format: OpenSSLFormatter
                    }),

                    /**
                     * Encrypts a message.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {WordArray|string} message The message to encrypt.
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {CipherParams} A cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     */
                    encrypt: function (cipher, message, key, cfg) {
                        // Apply config defaults
                        cfg = this.cfg.extend(cfg);

                        // Encrypt
                        var encryptor = cipher.createEncryptor(key, cfg);
                        var ciphertext = encryptor.finalize(message);

                        // Shortcut
                        var cipherCfg = encryptor.cfg;

                        // Create and return serializable cipher params
                        return CipherParams.create({
                            ciphertext: ciphertext,
                            key: key,
                            iv: cipherCfg.iv,
                            algorithm: cipher,
                            mode: cipherCfg.mode,
                            padding: cipherCfg.padding,
                            blockSize: cipher.blockSize,
                            formatter: cfg.format
                        });
                    },

                    /**
                     * Decrypts serialized ciphertext.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                     * @param {WordArray} key The key.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {WordArray} The plaintext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
                     */
                    decrypt: function (cipher, ciphertext, key, cfg) {
                        // Apply config defaults
                        cfg = this.cfg.extend(cfg);

                        // Convert string to CipherParams
                        ciphertext = this._parse(ciphertext, cfg.format);

                        // Decrypt
                        var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

                        return plaintext;
                    },

                    /**
                     * Converts serialized ciphertext to CipherParams,
                     * else assumed CipherParams already and returns ciphertext unchanged.
                     *
                     * @param {CipherParams|string} ciphertext The ciphertext.
                     * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
                     *
                     * @return {CipherParams} The unserialized ciphertext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
                     */
                    _parse: function (ciphertext, format) {
                        if (typeof ciphertext == 'string') {
                            return format.parse(ciphertext, this);
                        } else {
                            return ciphertext;
                        }
                    }
                });

                /**
                 * Key derivation function namespace.
                 */
                var C_kdf = C.kdf = {};

                /**
                 * OpenSSL key derivation function.
                 */
                var OpenSSLKdf = C_kdf.OpenSSL = {
                    /**
                     * Derives a key and IV from a password.
                     *
                     * @param {string} password The password to derive from.
                     * @param {number} keySize The size in words of the key to generate.
                     * @param {number} ivSize The size in words of the IV to generate.
                     * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
                     *
                     * @return {CipherParams} A cipher params object with the key, IV, and salt.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
                     *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
                     */
                    execute: function (password, keySize, ivSize, salt) {
                        // Generate random salt
                        if (!salt) {
                            salt = WordArray.random(64 / 8);
                        }

                        // Derive key and IV
                        var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

                        // Separate key and IV
                        var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                        key.sigBytes = keySize * 4;

                        // Return params
                        return CipherParams.create({ key: key, iv: iv, salt: salt });
                    }
                };

                /**
                 * A serializable cipher wrapper that derives the key from a password,
                 * and returns ciphertext as a serializable cipher params object.
                 */
                var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
                     */
                    cfg: SerializableCipher.cfg.extend({
                        kdf: OpenSSLKdf
                    }),

                    /**
                     * Encrypts a message using a password.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {WordArray|string} message The message to encrypt.
                     * @param {string} password The password.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {CipherParams} A cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
                     *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
                     */
                    encrypt: function (cipher, message, password, cfg) {
                        // Apply config defaults
                        cfg = this.cfg.extend(cfg);

                        // Derive key and other params
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

                        // Add IV to config
                        cfg.iv = derivedParams.iv;

                        // Encrypt
                        var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

                        // Mix in derived params
                        ciphertext.mixIn(derivedParams);

                        return ciphertext;
                    },

                    /**
                     * Decrypts serialized ciphertext using a password.
                     *
                     * @param {Cipher} cipher The cipher algorithm to use.
                     * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
                     * @param {string} password The password.
                     * @param {Object} cfg (Optional) The configuration options to use for this operation.
                     *
                     * @return {WordArray} The plaintext.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
                     *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
                     */
                    decrypt: function (cipher, ciphertext, password, cfg) {
                        // Apply config defaults
                        cfg = this.cfg.extend(cfg);

                        // Convert string to CipherParams
                        ciphertext = this._parse(ciphertext, cfg.format);

                        // Derive key and other params
                        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

                        // Add IV to config
                        cfg.iv = derivedParams.iv;

                        // Decrypt
                        var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

                        return plaintext;
                    }
                });
            }());


            /**
             * Cipher Feedback block mode.
             */
            CryptoJS.mode.CFB = (function () {
                var CFB = CryptoJS.lib.BlockCipherMode.extend();

                CFB.Encryptor = CFB.extend({
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;

                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

                        // Remember this block to use with next block
                        this._prevBlock = words.slice(offset, offset + blockSize);
                    }
                });

                CFB.Decryptor = CFB.extend({
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher;
                        var blockSize = cipher.blockSize;

                        // Remember this block to use with next block
                        var thisBlock = words.slice(offset, offset + blockSize);

                        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

                        // This block becomes the previous block
                        this._prevBlock = thisBlock;
                    }
                });

                function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
                    // Shortcut
                    var iv = this._iv;

                    // Generate keystream
                    if (iv) {
                        var keystream = iv.slice(0);

                        // Remove IV for subsequent blocks
                        this._iv = undefined;
                    } else {
                        var keystream = this._prevBlock;
                    }
                    cipher.encryptBlock(keystream, 0);

                    // Encrypt
                    for (var i = 0; i < blockSize; i++) {
                        words[offset + i] ^= keystream[i];
                    }
                }

                return CFB;
            }());


            /**
             * Electronic Codebook block mode.
             */
            CryptoJS.mode.ECB = (function () {
                var ECB = CryptoJS.lib.BlockCipherMode.extend();

                ECB.Encryptor = ECB.extend({
                    processBlock: function (words, offset) {
                        this._cipher.encryptBlock(words, offset);
                    }
                });

                ECB.Decryptor = ECB.extend({
                    processBlock: function (words, offset) {
                        this._cipher.decryptBlock(words, offset);
                    }
                });

                return ECB;
            }());


            /**
             * ANSI X.923 padding strategy.
             */
            CryptoJS.pad.AnsiX923 = {
                pad: function (data, blockSize) {
                    // Shortcuts
                    var dataSigBytes = data.sigBytes;
                    var blockSizeBytes = blockSize * 4;

                    // Count padding bytes
                    var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

                    // Compute last byte position
                    var lastBytePos = dataSigBytes + nPaddingBytes - 1;

                    // Pad
                    data.clamp();
                    data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
                    data.sigBytes += nPaddingBytes;
                },

                unpad: function (data) {
                    // Get number of padding bytes from last byte
                    var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

                    // Remove padding
                    data.sigBytes -= nPaddingBytes;
                }
            };


            /**
             * ISO 10126 padding strategy.
             */
            CryptoJS.pad.Iso10126 = {
                pad: function (data, blockSize) {
                    // Shortcut
                    var blockSizeBytes = blockSize * 4;

                    // Count padding bytes
                    var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

                    // Pad
                    data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
                        concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
                },

                unpad: function (data) {
                    // Get number of padding bytes from last byte
                    var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

                    // Remove padding
                    data.sigBytes -= nPaddingBytes;
                }
            };


            /**
             * ISO/IEC 9797-1 Padding Method 2.
             */
            CryptoJS.pad.Iso97971 = {
                pad: function (data, blockSize) {
                    // Add 0x80 byte
                    data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

                    // Zero pad the rest
                    CryptoJS.pad.ZeroPadding.pad(data, blockSize);
                },

                unpad: function (data) {
                    // Remove zero padding
                    CryptoJS.pad.ZeroPadding.unpad(data);

                    // Remove one more byte -- the 0x80 byte
                    data.sigBytes--;
                }
            };


            /**
             * Output Feedback block mode.
             */
            CryptoJS.mode.OFB = (function () {
                var OFB = CryptoJS.lib.BlockCipherMode.extend();

                var Encryptor = OFB.Encryptor = OFB.extend({
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var keystream = this._keystream;

                        // Generate keystream
                        if (iv) {
                            keystream = this._keystream = iv.slice(0);

                            // Remove IV for subsequent blocks
                            this._iv = undefined;
                        }
                        cipher.encryptBlock(keystream, 0);

                        // Encrypt
                        for (var i = 0; i < blockSize; i++) {
                            words[offset + i] ^= keystream[i];
                        }
                    }
                });

                OFB.Decryptor = Encryptor;

                return OFB;
            }());


            /**
             * A noop padding strategy.
             */
            CryptoJS.pad.NoPadding = {
                pad: function () {
                },

                unpad: function () {
                }
            };


            (function (undefined) {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var CipherParams = C_lib.CipherParams;
                var C_enc = C.enc;
                var Hex = C_enc.Hex;
                var C_format = C.format;

                var HexFormatter = C_format.Hex = {
                    /**
                     * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
                     *
                     * @param {CipherParams} cipherParams The cipher params object.
                     *
                     * @return {string} The hexadecimally encoded string.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
                     */
                    stringify: function (cipherParams) {
                        return cipherParams.ciphertext.toString(Hex);
                    },

                    /**
                     * Converts a hexadecimally encoded ciphertext string to a cipher params object.
                     *
                     * @param {string} input The hexadecimally encoded string.
                     *
                     * @return {CipherParams} The cipher params object.
                     *
                     * @static
                     *
                     * @example
                     *
                     *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
                     */
                    parse: function (input) {
                        var ciphertext = Hex.parse(input);
                        return CipherParams.create({ ciphertext: ciphertext });
                    }
                };
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var BlockCipher = C_lib.BlockCipher;
                var C_algo = C.algo;

                // Lookup tables
                var SBOX = [];
                var INV_SBOX = [];
                var SUB_MIX_0 = [];
                var SUB_MIX_1 = [];
                var SUB_MIX_2 = [];
                var SUB_MIX_3 = [];
                var INV_SUB_MIX_0 = [];
                var INV_SUB_MIX_1 = [];
                var INV_SUB_MIX_2 = [];
                var INV_SUB_MIX_3 = [];

                // Compute lookup tables
                (function () {
                    // Compute double table
                    var d = [];
                    for (var i = 0; i < 256; i++) {
                        if (i < 128) {
                            d[i] = i << 1;
                        } else {
                            d[i] = (i << 1) ^ 0x11b;
                        }
                    }

                    // Walk GF(2^8)
                    var x = 0;
                    var xi = 0;
                    for (var i = 0; i < 256; i++) {
                        // Compute sbox
                        var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
                        sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
                        SBOX[x] = sx;
                        INV_SBOX[sx] = x;

                        // Compute multiplication
                        var x2 = d[x];
                        var x4 = d[x2];
                        var x8 = d[x4];

                        // Compute sub bytes, mix columns tables
                        var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
                        SUB_MIX_0[x] = (t << 24) | (t >>> 8);
                        SUB_MIX_1[x] = (t << 16) | (t >>> 16);
                        SUB_MIX_2[x] = (t << 8) | (t >>> 24);
                        SUB_MIX_3[x] = t;

                        // Compute inv sub bytes, inv mix columns tables
                        var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
                        INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
                        INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
                        INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);
                        INV_SUB_MIX_3[sx] = t;

                        // Compute next counter
                        if (!x) {
                            x = xi = 1;
                        } else {
                            x = x2 ^ d[d[d[x8 ^ x2]]];
                            xi ^= d[d[xi]];
                        }
                    }
                }());

                // Precomputed Rcon lookup
                var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

                /**
                 * AES block cipher algorithm.
                 */
                var AES = C_algo.AES = BlockCipher.extend({
                    _doReset: function () {
                        // Skip reset of nRounds has been set before and key did not change
                        if (this._nRounds && this._keyPriorReset === this._key) {
                            return;
                        }

                        // Shortcuts
                        var key = this._keyPriorReset = this._key;
                        var keyWords = key.words;
                        var keySize = key.sigBytes / 4;

                        // Compute number of rounds
                        var nRounds = this._nRounds = keySize + 6;

                        // Compute number of key schedule rows
                        var ksRows = (nRounds + 1) * 4;

                        // Compute key schedule
                        var keySchedule = this._keySchedule = [];
                        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                            if (ksRow < keySize) {
                                keySchedule[ksRow] = keyWords[ksRow];
                            } else {
                                var t = keySchedule[ksRow - 1];

                                if (!(ksRow % keySize)) {
                                    // Rot word
                                    t = (t << 8) | (t >>> 24);

                                    // Sub word
                                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

                                    // Mix Rcon
                                    t ^= RCON[(ksRow / keySize) | 0] << 24;
                                } else if (keySize > 6 && ksRow % keySize == 4) {
                                    // Sub word
                                    t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
                                }

                                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                            }
                        }

                        // Compute inv key schedule
                        var invKeySchedule = this._invKeySchedule = [];
                        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                            var ksRow = ksRows - invKsRow;

                            if (invKsRow % 4) {
                                var t = keySchedule[ksRow];
                            } else {
                                var t = keySchedule[ksRow - 4];
                            }

                            if (invKsRow < 4 || ksRow <= 4) {
                                invKeySchedule[invKsRow] = t;
                            } else {
                                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
                                    INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                            }
                        }
                    },

                    encryptBlock: function (M, offset) {
                        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
                    },

                    decryptBlock: function (M, offset) {
                        // Swap 2nd and 4th rows
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;

                        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

                        // Inv swap 2nd and 4th rows
                        var t = M[offset + 1];
                        M[offset + 1] = M[offset + 3];
                        M[offset + 3] = t;
                    },

                    _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                        // Shortcut
                        var nRounds = this._nRounds;

                        // Get input, add round key
                        var s0 = M[offset] ^ keySchedule[0];
                        var s1 = M[offset + 1] ^ keySchedule[1];
                        var s2 = M[offset + 2] ^ keySchedule[2];
                        var s3 = M[offset + 3] ^ keySchedule[3];

                        // Key schedule row counter
                        var ksRow = 4;

                        // Rounds
                        for (var round = 1; round < nRounds; round++) {
                            // Shift rows, sub bytes, mix columns, add round key
                            var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                            var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                            var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                            var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                            // Update state
                            s0 = t0;
                            s1 = t1;
                            s2 = t2;
                            s3 = t3;
                        }

                        // Shift rows, sub bytes, add round key
                        var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                        var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                        var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                        var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

                        // Set output
                        M[offset] = t0;
                        M[offset + 1] = t1;
                        M[offset + 2] = t2;
                        M[offset + 3] = t3;
                    },

                    keySize: 256 / 32
                });

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
                 */
                C.AES = BlockCipher._createHelper(AES);
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var WordArray = C_lib.WordArray;
                var BlockCipher = C_lib.BlockCipher;
                var C_algo = C.algo;

                // Permuted Choice 1 constants
                var PC1 = [
                    57, 49, 41, 33, 25, 17, 9, 1,
                    58, 50, 42, 34, 26, 18, 10, 2,
                    59, 51, 43, 35, 27, 19, 11, 3,
                    60, 52, 44, 36, 63, 55, 47, 39,
                    31, 23, 15, 7, 62, 54, 46, 38,
                    30, 22, 14, 6, 61, 53, 45, 37,
                    29, 21, 13, 5, 28, 20, 12, 4
                ];

                // Permuted Choice 2 constants
                var PC2 = [
                    14, 17, 11, 24, 1, 5,
                    3, 28, 15, 6, 21, 10,
                    23, 19, 12, 4, 26, 8,
                    16, 7, 27, 20, 13, 2,
                    41, 52, 31, 37, 47, 55,
                    30, 40, 51, 45, 33, 48,
                    44, 49, 39, 56, 34, 53,
                    46, 42, 50, 36, 29, 32
                ];

                // Cumulative bit shift constants
                var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

                // SBOXes and round permutation constants
                var SBOX_P = [
                    {
                        0x0: 0x808200,
                        0x10000000: 0x8000,
                        0x20000000: 0x808002,
                        0x30000000: 0x2,
                        0x40000000: 0x200,
                        0x50000000: 0x808202,
                        0x60000000: 0x800202,
                        0x70000000: 0x800000,
                        0x80000000: 0x202,
                        0x90000000: 0x800200,
                        0xa0000000: 0x8200,
                        0xb0000000: 0x808000,
                        0xc0000000: 0x8002,
                        0xd0000000: 0x800002,
                        0xe0000000: 0x0,
                        0xf0000000: 0x8202,
                        0x8000000: 0x0,
                        0x18000000: 0x808202,
                        0x28000000: 0x8202,
                        0x38000000: 0x8000,
                        0x48000000: 0x808200,
                        0x58000000: 0x200,
                        0x68000000: 0x808002,
                        0x78000000: 0x2,
                        0x88000000: 0x800200,
                        0x98000000: 0x8200,
                        0xa8000000: 0x808000,
                        0xb8000000: 0x800202,
                        0xc8000000: 0x800002,
                        0xd8000000: 0x8002,
                        0xe8000000: 0x202,
                        0xf8000000: 0x800000,
                        0x1: 0x8000,
                        0x10000001: 0x2,
                        0x20000001: 0x808200,
                        0x30000001: 0x800000,
                        0x40000001: 0x808002,
                        0x50000001: 0x8200,
                        0x60000001: 0x200,
                        0x70000001: 0x800202,
                        0x80000001: 0x808202,
                        0x90000001: 0x808000,
                        0xa0000001: 0x800002,
                        0xb0000001: 0x8202,
                        0xc0000001: 0x202,
                        0xd0000001: 0x800200,
                        0xe0000001: 0x8002,
                        0xf0000001: 0x0,
                        0x8000001: 0x808202,
                        0x18000001: 0x808000,
                        0x28000001: 0x800000,
                        0x38000001: 0x200,
                        0x48000001: 0x8000,
                        0x58000001: 0x800002,
                        0x68000001: 0x2,
                        0x78000001: 0x8202,
                        0x88000001: 0x8002,
                        0x98000001: 0x800202,
                        0xa8000001: 0x202,
                        0xb8000001: 0x808200,
                        0xc8000001: 0x800200,
                        0xd8000001: 0x0,
                        0xe8000001: 0x8200,
                        0xf8000001: 0x808002
                    },
                    {
                        0x0: 0x40084010,
                        0x1000000: 0x4000,
                        0x2000000: 0x80000,
                        0x3000000: 0x40080010,
                        0x4000000: 0x40000010,
                        0x5000000: 0x40084000,
                        0x6000000: 0x40004000,
                        0x7000000: 0x10,
                        0x8000000: 0x84000,
                        0x9000000: 0x40004010,
                        0xa000000: 0x40000000,
                        0xb000000: 0x84010,
                        0xc000000: 0x80010,
                        0xd000000: 0x0,
                        0xe000000: 0x4010,
                        0xf000000: 0x40080000,
                        0x800000: 0x40004000,
                        0x1800000: 0x84010,
                        0x2800000: 0x10,
                        0x3800000: 0x40004010,
                        0x4800000: 0x40084010,
                        0x5800000: 0x40000000,
                        0x6800000: 0x80000,
                        0x7800000: 0x40080010,
                        0x8800000: 0x80010,
                        0x9800000: 0x0,
                        0xa800000: 0x4000,
                        0xb800000: 0x40080000,
                        0xc800000: 0x40000010,
                        0xd800000: 0x84000,
                        0xe800000: 0x40084000,
                        0xf800000: 0x4010,
                        0x10000000: 0x0,
                        0x11000000: 0x40080010,
                        0x12000000: 0x40004010,
                        0x13000000: 0x40084000,
                        0x14000000: 0x40080000,
                        0x15000000: 0x10,
                        0x16000000: 0x84010,
                        0x17000000: 0x4000,
                        0x18000000: 0x4010,
                        0x19000000: 0x80000,
                        0x1a000000: 0x80010,
                        0x1b000000: 0x40000010,
                        0x1c000000: 0x84000,
                        0x1d000000: 0x40004000,
                        0x1e000000: 0x40000000,
                        0x1f000000: 0x40084010,
                        0x10800000: 0x84010,
                        0x11800000: 0x80000,
                        0x12800000: 0x40080000,
                        0x13800000: 0x4000,
                        0x14800000: 0x40004000,
                        0x15800000: 0x40084010,
                        0x16800000: 0x10,
                        0x17800000: 0x40000000,
                        0x18800000: 0x40084000,
                        0x19800000: 0x40000010,
                        0x1a800000: 0x40004010,
                        0x1b800000: 0x80010,
                        0x1c800000: 0x0,
                        0x1d800000: 0x4010,
                        0x1e800000: 0x40080010,
                        0x1f800000: 0x84000
                    },
                    {
                        0x0: 0x104,
                        0x100000: 0x0,
                        0x200000: 0x4000100,
                        0x300000: 0x10104,
                        0x400000: 0x10004,
                        0x500000: 0x4000004,
                        0x600000: 0x4010104,
                        0x700000: 0x4010000,
                        0x800000: 0x4000000,
                        0x900000: 0x4010100,
                        0xa00000: 0x10100,
                        0xb00000: 0x4010004,
                        0xc00000: 0x4000104,
                        0xd00000: 0x10000,
                        0xe00000: 0x4,
                        0xf00000: 0x100,
                        0x80000: 0x4010100,
                        0x180000: 0x4010004,
                        0x280000: 0x0,
                        0x380000: 0x4000100,
                        0x480000: 0x4000004,
                        0x580000: 0x10000,
                        0x680000: 0x10004,
                        0x780000: 0x104,
                        0x880000: 0x4,
                        0x980000: 0x100,
                        0xa80000: 0x4010000,
                        0xb80000: 0x10104,
                        0xc80000: 0x10100,
                        0xd80000: 0x4000104,
                        0xe80000: 0x4010104,
                        0xf80000: 0x4000000,
                        0x1000000: 0x4010100,
                        0x1100000: 0x10004,
                        0x1200000: 0x10000,
                        0x1300000: 0x4000100,
                        0x1400000: 0x100,
                        0x1500000: 0x4010104,
                        0x1600000: 0x4000004,
                        0x1700000: 0x0,
                        0x1800000: 0x4000104,
                        0x1900000: 0x4000000,
                        0x1a00000: 0x4,
                        0x1b00000: 0x10100,
                        0x1c00000: 0x4010000,
                        0x1d00000: 0x104,
                        0x1e00000: 0x10104,
                        0x1f00000: 0x4010004,
                        0x1080000: 0x4000000,
                        0x1180000: 0x104,
                        0x1280000: 0x4010100,
                        0x1380000: 0x0,
                        0x1480000: 0x10004,
                        0x1580000: 0x4000100,
                        0x1680000: 0x100,
                        0x1780000: 0x4010004,
                        0x1880000: 0x10000,
                        0x1980000: 0x4010104,
                        0x1a80000: 0x10104,
                        0x1b80000: 0x4000004,
                        0x1c80000: 0x4000104,
                        0x1d80000: 0x4010000,
                        0x1e80000: 0x4,
                        0x1f80000: 0x10100
                    },
                    {
                        0x0: 0x80401000,
                        0x10000: 0x80001040,
                        0x20000: 0x401040,
                        0x30000: 0x80400000,
                        0x40000: 0x0,
                        0x50000: 0x401000,
                        0x60000: 0x80000040,
                        0x70000: 0x400040,
                        0x80000: 0x80000000,
                        0x90000: 0x400000,
                        0xa0000: 0x40,
                        0xb0000: 0x80001000,
                        0xc0000: 0x80400040,
                        0xd0000: 0x1040,
                        0xe0000: 0x1000,
                        0xf0000: 0x80401040,
                        0x8000: 0x80001040,
                        0x18000: 0x40,
                        0x28000: 0x80400040,
                        0x38000: 0x80001000,
                        0x48000: 0x401000,
                        0x58000: 0x80401040,
                        0x68000: 0x0,
                        0x78000: 0x80400000,
                        0x88000: 0x1000,
                        0x98000: 0x80401000,
                        0xa8000: 0x400000,
                        0xb8000: 0x1040,
                        0xc8000: 0x80000000,
                        0xd8000: 0x400040,
                        0xe8000: 0x401040,
                        0xf8000: 0x80000040,
                        0x100000: 0x400040,
                        0x110000: 0x401000,
                        0x120000: 0x80000040,
                        0x130000: 0x0,
                        0x140000: 0x1040,
                        0x150000: 0x80400040,
                        0x160000: 0x80401000,
                        0x170000: 0x80001040,
                        0x180000: 0x80401040,
                        0x190000: 0x80000000,
                        0x1a0000: 0x80400000,
                        0x1b0000: 0x401040,
                        0x1c0000: 0x80001000,
                        0x1d0000: 0x400000,
                        0x1e0000: 0x40,
                        0x1f0000: 0x1000,
                        0x108000: 0x80400000,
                        0x118000: 0x80401040,
                        0x128000: 0x0,
                        0x138000: 0x401000,
                        0x148000: 0x400040,
                        0x158000: 0x80000000,
                        0x168000: 0x80001040,
                        0x178000: 0x40,
                        0x188000: 0x80000040,
                        0x198000: 0x1000,
                        0x1a8000: 0x80001000,
                        0x1b8000: 0x80400040,
                        0x1c8000: 0x1040,
                        0x1d8000: 0x80401000,
                        0x1e8000: 0x400000,
                        0x1f8000: 0x401040
                    },
                    {
                        0x0: 0x80,
                        0x1000: 0x1040000,
                        0x2000: 0x40000,
                        0x3000: 0x20000000,
                        0x4000: 0x20040080,
                        0x5000: 0x1000080,
                        0x6000: 0x21000080,
                        0x7000: 0x40080,
                        0x8000: 0x1000000,
                        0x9000: 0x20040000,
                        0xa000: 0x20000080,
                        0xb000: 0x21040080,
                        0xc000: 0x21040000,
                        0xd000: 0x0,
                        0xe000: 0x1040080,
                        0xf000: 0x21000000,
                        0x800: 0x1040080,
                        0x1800: 0x21000080,
                        0x2800: 0x80,
                        0x3800: 0x1040000,
                        0x4800: 0x40000,
                        0x5800: 0x20040080,
                        0x6800: 0x21040000,
                        0x7800: 0x20000000,
                        0x8800: 0x20040000,
                        0x9800: 0x0,
                        0xa800: 0x21040080,
                        0xb800: 0x1000080,
                        0xc800: 0x20000080,
                        0xd800: 0x21000000,
                        0xe800: 0x1000000,
                        0xf800: 0x40080,
                        0x10000: 0x40000,
                        0x11000: 0x80,
                        0x12000: 0x20000000,
                        0x13000: 0x21000080,
                        0x14000: 0x1000080,
                        0x15000: 0x21040000,
                        0x16000: 0x20040080,
                        0x17000: 0x1000000,
                        0x18000: 0x21040080,
                        0x19000: 0x21000000,
                        0x1a000: 0x1040000,
                        0x1b000: 0x20040000,
                        0x1c000: 0x40080,
                        0x1d000: 0x20000080,
                        0x1e000: 0x0,
                        0x1f000: 0x1040080,
                        0x10800: 0x21000080,
                        0x11800: 0x1000000,
                        0x12800: 0x1040000,
                        0x13800: 0x20040080,
                        0x14800: 0x20000000,
                        0x15800: 0x1040080,
                        0x16800: 0x80,
                        0x17800: 0x21040000,
                        0x18800: 0x40080,
                        0x19800: 0x21040080,
                        0x1a800: 0x0,
                        0x1b800: 0x21000000,
                        0x1c800: 0x1000080,
                        0x1d800: 0x40000,
                        0x1e800: 0x20040000,
                        0x1f800: 0x20000080
                    },
                    {
                        0x0: 0x10000008,
                        0x100: 0x2000,
                        0x200: 0x10200000,
                        0x300: 0x10202008,
                        0x400: 0x10002000,
                        0x500: 0x200000,
                        0x600: 0x200008,
                        0x700: 0x10000000,
                        0x800: 0x0,
                        0x900: 0x10002008,
                        0xa00: 0x202000,
                        0xb00: 0x8,
                        0xc00: 0x10200008,
                        0xd00: 0x202008,
                        0xe00: 0x2008,
                        0xf00: 0x10202000,
                        0x80: 0x10200000,
                        0x180: 0x10202008,
                        0x280: 0x8,
                        0x380: 0x200000,
                        0x480: 0x202008,
                        0x580: 0x10000008,
                        0x680: 0x10002000,
                        0x780: 0x2008,
                        0x880: 0x200008,
                        0x980: 0x2000,
                        0xa80: 0x10002008,
                        0xb80: 0x10200008,
                        0xc80: 0x0,
                        0xd80: 0x10202000,
                        0xe80: 0x202000,
                        0xf80: 0x10000000,
                        0x1000: 0x10002000,
                        0x1100: 0x10200008,
                        0x1200: 0x10202008,
                        0x1300: 0x2008,
                        0x1400: 0x200000,
                        0x1500: 0x10000000,
                        0x1600: 0x10000008,
                        0x1700: 0x202000,
                        0x1800: 0x202008,
                        0x1900: 0x0,
                        0x1a00: 0x8,
                        0x1b00: 0x10200000,
                        0x1c00: 0x2000,
                        0x1d00: 0x10002008,
                        0x1e00: 0x10202000,
                        0x1f00: 0x200008,
                        0x1080: 0x8,
                        0x1180: 0x202000,
                        0x1280: 0x200000,
                        0x1380: 0x10000008,
                        0x1480: 0x10002000,
                        0x1580: 0x2008,
                        0x1680: 0x10202008,
                        0x1780: 0x10200000,
                        0x1880: 0x10202000,
                        0x1980: 0x10200008,
                        0x1a80: 0x2000,
                        0x1b80: 0x202008,
                        0x1c80: 0x200008,
                        0x1d80: 0x0,
                        0x1e80: 0x10000000,
                        0x1f80: 0x10002008
                    },
                    {
                        0x0: 0x100000,
                        0x10: 0x2000401,
                        0x20: 0x400,
                        0x30: 0x100401,
                        0x40: 0x2100401,
                        0x50: 0x0,
                        0x60: 0x1,
                        0x70: 0x2100001,
                        0x80: 0x2000400,
                        0x90: 0x100001,
                        0xa0: 0x2000001,
                        0xb0: 0x2100400,
                        0xc0: 0x2100000,
                        0xd0: 0x401,
                        0xe0: 0x100400,
                        0xf0: 0x2000000,
                        0x8: 0x2100001,
                        0x18: 0x0,
                        0x28: 0x2000401,
                        0x38: 0x2100400,
                        0x48: 0x100000,
                        0x58: 0x2000001,
                        0x68: 0x2000000,
                        0x78: 0x401,
                        0x88: 0x100401,
                        0x98: 0x2000400,
                        0xa8: 0x2100000,
                        0xb8: 0x100001,
                        0xc8: 0x400,
                        0xd8: 0x2100401,
                        0xe8: 0x1,
                        0xf8: 0x100400,
                        0x100: 0x2000000,
                        0x110: 0x100000,
                        0x120: 0x2000401,
                        0x130: 0x2100001,
                        0x140: 0x100001,
                        0x150: 0x2000400,
                        0x160: 0x2100400,
                        0x170: 0x100401,
                        0x180: 0x401,
                        0x190: 0x2100401,
                        0x1a0: 0x100400,
                        0x1b0: 0x1,
                        0x1c0: 0x0,
                        0x1d0: 0x2100000,
                        0x1e0: 0x2000001,
                        0x1f0: 0x400,
                        0x108: 0x100400,
                        0x118: 0x2000401,
                        0x128: 0x2100001,
                        0x138: 0x1,
                        0x148: 0x2000000,
                        0x158: 0x100000,
                        0x168: 0x401,
                        0x178: 0x2100400,
                        0x188: 0x2000001,
                        0x198: 0x2100000,
                        0x1a8: 0x0,
                        0x1b8: 0x2100401,
                        0x1c8: 0x100401,
                        0x1d8: 0x400,
                        0x1e8: 0x2000400,
                        0x1f8: 0x100001
                    },
                    {
                        0x0: 0x8000820,
                        0x1: 0x20000,
                        0x2: 0x8000000,
                        0x3: 0x20,
                        0x4: 0x20020,
                        0x5: 0x8020820,
                        0x6: 0x8020800,
                        0x7: 0x800,
                        0x8: 0x8020000,
                        0x9: 0x8000800,
                        0xa: 0x20800,
                        0xb: 0x8020020,
                        0xc: 0x820,
                        0xd: 0x0,
                        0xe: 0x8000020,
                        0xf: 0x20820,
                        0x80000000: 0x800,
                        0x80000001: 0x8020820,
                        0x80000002: 0x8000820,
                        0x80000003: 0x8000000,
                        0x80000004: 0x8020000,
                        0x80000005: 0x20800,
                        0x80000006: 0x20820,
                        0x80000007: 0x20,
                        0x80000008: 0x8000020,
                        0x80000009: 0x820,
                        0x8000000a: 0x20020,
                        0x8000000b: 0x8020800,
                        0x8000000c: 0x0,
                        0x8000000d: 0x8020020,
                        0x8000000e: 0x8000800,
                        0x8000000f: 0x20000,
                        0x10: 0x20820,
                        0x11: 0x8020800,
                        0x12: 0x20,
                        0x13: 0x800,
                        0x14: 0x8000800,
                        0x15: 0x8000020,
                        0x16: 0x8020020,
                        0x17: 0x20000,
                        0x18: 0x0,
                        0x19: 0x20020,
                        0x1a: 0x8020000,
                        0x1b: 0x8000820,
                        0x1c: 0x8020820,
                        0x1d: 0x20800,
                        0x1e: 0x820,
                        0x1f: 0x8000000,
                        0x80000010: 0x20000,
                        0x80000011: 0x800,
                        0x80000012: 0x8020020,
                        0x80000013: 0x20820,
                        0x80000014: 0x20,
                        0x80000015: 0x8020000,
                        0x80000016: 0x8000000,
                        0x80000017: 0x8000820,
                        0x80000018: 0x8020820,
                        0x80000019: 0x8000020,
                        0x8000001a: 0x8000800,
                        0x8000001b: 0x0,
                        0x8000001c: 0x20800,
                        0x8000001d: 0x820,
                        0x8000001e: 0x20020,
                        0x8000001f: 0x8020800
                    }
                ];

                // Masks that select the SBOX input
                var SBOX_MASK = [
                    0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
                    0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
                ];

                /**
                 * DES block cipher algorithm.
                 */
                var DES = C_algo.DES = BlockCipher.extend({
                    _doReset: function () {
                        // Shortcuts
                        var key = this._key;
                        var keyWords = key.words;

                        // Select 56 bits according to PC1
                        var keyBits = [];
                        for (var i = 0; i < 56; i++) {
                            var keyBitPos = PC1[i] - 1;
                            keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
                        }

                        // Assemble 16 subkeys
                        var subKeys = this._subKeys = [];
                        for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                            // Create subkey
                            var subKey = subKeys[nSubKey] = [];

                            // Shortcut
                            var bitShift = BIT_SHIFTS[nSubKey];

                            // Select 48 bits according to PC2
                            for (var i = 0; i < 24; i++) {
                                // Select from the left 28 key bits
                                subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

                                // Select from the right 28 key bits
                                subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
                            }

                            // Since each subkey is applied to an expanded 32-bit input,
                            // the subkey can be broken into 8 values scaled to 32-bits,
                            // which allows the key to be used without expansion
                            subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
                            for (var i = 1; i < 7; i++) {
                                subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
                            }
                            subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
                        }

                        // Compute inverse subkeys
                        var invSubKeys = this._invSubKeys = [];
                        for (var i = 0; i < 16; i++) {
                            invSubKeys[i] = subKeys[15 - i];
                        }
                    },

                    encryptBlock: function (M, offset) {
                        this._doCryptBlock(M, offset, this._subKeys);
                    },

                    decryptBlock: function (M, offset) {
                        this._doCryptBlock(M, offset, this._invSubKeys);
                    },

                    _doCryptBlock: function (M, offset, subKeys) {
                        // Get input
                        this._lBlock = M[offset];
                        this._rBlock = M[offset + 1];

                        // Initial permutation
                        exchangeLR.call(this, 4, 0x0f0f0f0f);
                        exchangeLR.call(this, 16, 0x0000ffff);
                        exchangeRL.call(this, 2, 0x33333333);
                        exchangeRL.call(this, 8, 0x00ff00ff);
                        exchangeLR.call(this, 1, 0x55555555);

                        // Rounds
                        for (var round = 0; round < 16; round++) {
                            // Shortcuts
                            var subKey = subKeys[round];
                            var lBlock = this._lBlock;
                            var rBlock = this._rBlock;

                            // Feistel function
                            var f = 0;
                            for (var i = 0; i < 8; i++) {
                                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                            }
                            this._lBlock = rBlock;
                            this._rBlock = lBlock ^ f;
                        }

                        // Undo swap from last round
                        var t = this._lBlock;
                        this._lBlock = this._rBlock;
                        this._rBlock = t;

                        // Final permutation
                        exchangeLR.call(this, 1, 0x55555555);
                        exchangeRL.call(this, 8, 0x00ff00ff);
                        exchangeRL.call(this, 2, 0x33333333);
                        exchangeLR.call(this, 16, 0x0000ffff);
                        exchangeLR.call(this, 4, 0x0f0f0f0f);

                        // Set output
                        M[offset] = this._lBlock;
                        M[offset + 1] = this._rBlock;
                    },

                    keySize: 64 / 32,

                    ivSize: 64 / 32,

                    blockSize: 64 / 32
                });

                // Swap bits across the left and right words
                function exchangeLR(offset, mask) {
                    var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
                    this._rBlock ^= t;
                    this._lBlock ^= t << offset;
                }

                function exchangeRL(offset, mask) {
                    var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
                    this._lBlock ^= t;
                    this._rBlock ^= t << offset;
                }

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
                 */
                C.DES = BlockCipher._createHelper(DES);

                /**
                 * Triple-DES block cipher algorithm.
                 */
                var TripleDES = C_algo.TripleDES = BlockCipher.extend({
                    _doReset: function () {
                        // Shortcuts
                        var key = this._key;
                        var keyWords = key.words;

                        // Create DES instances
                        this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
                        this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
                        this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
                    },

                    encryptBlock: function (M, offset) {
                        this._des1.encryptBlock(M, offset);
                        this._des2.decryptBlock(M, offset);
                        this._des3.encryptBlock(M, offset);
                    },

                    decryptBlock: function (M, offset) {
                        this._des3.decryptBlock(M, offset);
                        this._des2.encryptBlock(M, offset);
                        this._des1.decryptBlock(M, offset);
                    },

                    keySize: 192 / 32,

                    ivSize: 64 / 32,

                    blockSize: 64 / 32
                });

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
                 */
                C.TripleDES = BlockCipher._createHelper(TripleDES);
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var StreamCipher = C_lib.StreamCipher;
                var C_algo = C.algo;

                /**
                 * RC4 stream cipher algorithm.
                 */
                var RC4 = C_algo.RC4 = StreamCipher.extend({
                    _doReset: function () {
                        // Shortcuts
                        var key = this._key;
                        var keyWords = key.words;
                        var keySigBytes = key.sigBytes;

                        // Init sbox
                        var S = this._S = [];
                        for (var i = 0; i < 256; i++) {
                            S[i] = i;
                        }

                        // Key setup
                        for (var i = 0, j = 0; i < 256; i++) {
                            var keyByteIndex = i % keySigBytes;
                            var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

                            j = (j + S[i] + keyByte) % 256;

                            // Swap
                            var t = S[i];
                            S[i] = S[j];
                            S[j] = t;
                        }

                        // Counters
                        this._i = this._j = 0;
                    },

                    _doProcessBlock: function (M, offset) {
                        M[offset] ^= generateKeystreamWord.call(this);
                    },

                    keySize: 256 / 32,

                    ivSize: 0
                });

                function generateKeystreamWord() {
                    // Shortcuts
                    var S = this._S;
                    var i = this._i;
                    var j = this._j;

                    // Generate keystream word
                    var keystreamWord = 0;
                    for (var n = 0; n < 4; n++) {
                        i = (i + 1) % 256;
                        j = (j + S[i]) % 256;

                        // Swap
                        var t = S[i];
                        S[i] = S[j];
                        S[j] = t;

                        keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
                    }

                    // Update counters
                    this._i = i;
                    this._j = j;

                    return keystreamWord;
                }

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
                 */
                C.RC4 = StreamCipher._createHelper(RC4);

                /**
                 * Modified RC4 stream cipher algorithm.
                 */
                var RC4Drop = C_algo.RC4Drop = RC4.extend({
                    /**
                     * Configuration options.
                     *
                     * @property {number} drop The number of keystream words to drop. Default 192
                     */
                    cfg: RC4.cfg.extend({
                        drop: 192
                    }),

                    _doReset: function () {
                        RC4._doReset.call(this);

                        // Drop
                        for (var i = this.cfg.drop; i > 0; i--) {
                            generateKeystreamWord.call(this);
                        }
                    }
                });

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
                 */
                C.RC4Drop = StreamCipher._createHelper(RC4Drop);
            }());


            /** @preserve
             * Counter block mode compatible with  Dr Brian Gladman fileenc.c
             * derived from CryptoJS.mode.CTR
             * Jan Hruby jhruby.web@gmail.com
             */
            CryptoJS.mode.CTRGladman = (function () {
                var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

                function incWord(word) {
                    if (((word >> 24) & 0xff) === 0xff) { //overflow
                        var b1 = (word >> 16) & 0xff;
                        var b2 = (word >> 8) & 0xff;
                        var b3 = word & 0xff;

                        if (b1 === 0xff) // overflow b1
                        {
                            b1 = 0;
                            if (b2 === 0xff) {
                                b2 = 0;
                                if (b3 === 0xff) {
                                    b3 = 0;
                                }
                                else {
                                    ++b3;
                                }
                            }
                            else {
                                ++b2;
                            }
                        }
                        else {
                            ++b1;
                        }

                        word = 0;
                        word += (b1 << 16);
                        word += (b2 << 8);
                        word += b3;
                    }
                    else {
                        word += (0x01 << 24);
                    }
                    return word;
                }

                function incCounter(counter) {
                    if ((counter[0] = incWord(counter[0])) === 0) {
                        // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
                        counter[1] = incWord(counter[1]);
                    }
                    return counter;
                }

                var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;

                        // Generate keystream
                        if (iv) {
                            counter = this._counter = iv.slice(0);

                            // Remove IV for subsequent blocks
                            this._iv = undefined;
                        }

                        incCounter(counter);

                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);

                        // Encrypt
                        for (var i = 0; i < blockSize; i++) {
                            words[offset + i] ^= keystream[i];
                        }
                    }
                });

                CTRGladman.Decryptor = Encryptor;

                return CTRGladman;
            }());




            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var StreamCipher = C_lib.StreamCipher;
                var C_algo = C.algo;

                // Reusable objects
                var S = [];
                var C_ = [];
                var G = [];

                /**
                 * Rabbit stream cipher algorithm
                 */
                var Rabbit = C_algo.Rabbit = StreamCipher.extend({
                    _doReset: function () {
                        // Shortcuts
                        var K = this._key.words;
                        var iv = this.cfg.iv;

                        // Swap endian
                        for (var i = 0; i < 4; i++) {
                            K[i] = (((K[i] << 8) | (K[i] >>> 24)) & 0x00ff00ff) |
                                (((K[i] << 24) | (K[i] >>> 8)) & 0xff00ff00);
                        }

                        // Generate initial state values
                        var X = this._X = [
                            K[0], (K[3] << 16) | (K[2] >>> 16),
                            K[1], (K[0] << 16) | (K[3] >>> 16),
                            K[2], (K[1] << 16) | (K[0] >>> 16),
                            K[3], (K[2] << 16) | (K[1] >>> 16)
                        ];

                        // Generate initial counter values
                        var C = this._C = [
                            (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                            (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                            (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                            (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                        ];

                        // Carry bit
                        this._b = 0;

                        // Iterate the system four times
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }

                        // Modify the counters
                        for (var i = 0; i < 8; i++) {
                            C[i] ^= X[(i + 4) & 7];
                        }

                        // IV setup
                        if (iv) {
                            // Shortcuts
                            var IV = iv.words;
                            var IV_0 = IV[0];
                            var IV_1 = IV[1];

                            // Generate four subvectors
                            var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                            var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                            var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                            var i3 = (i2 << 16) | (i0 & 0x0000ffff);

                            // Modify counter values
                            C[0] ^= i0;
                            C[1] ^= i1;
                            C[2] ^= i2;
                            C[3] ^= i3;
                            C[4] ^= i0;
                            C[5] ^= i1;
                            C[6] ^= i2;
                            C[7] ^= i3;

                            // Iterate the system four times
                            for (var i = 0; i < 4; i++) {
                                nextState.call(this);
                            }
                        }
                    },

                    _doProcessBlock: function (M, offset) {
                        // Shortcut
                        var X = this._X;

                        // Iterate the system
                        nextState.call(this);

                        // Generate four keystream words
                        S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                        S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                        S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                        S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

                        for (var i = 0; i < 4; i++) {
                            // Swap endian
                            S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) |
                                (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);

                            // Encrypt
                            M[offset + i] ^= S[i];
                        }
                    },

                    blockSize: 128 / 32,

                    ivSize: 64 / 32
                });

                function nextState() {
                    // Shortcuts
                    var X = this._X;
                    var C = this._C;

                    // Save old counter values
                    for (var i = 0; i < 8; i++) {
                        C_[i] = C[i];
                    }

                    // Calculate new counter values
                    C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                    C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                    C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                    C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                    C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                    C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                    C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                    C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                    this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

                    // Calculate the g-values
                    for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C[i];

                        // Construct high and low argument for squaring
                        var ga = gx & 0xffff;
                        var gb = gx >>> 16;

                        // Calculate high and low result of squaring
                        var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                        var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

                        // High XOR low
                        G[i] = gh ^ gl;
                    }

                    // Calculate new state values
                    X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                    X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
                    X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                    X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
                    X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                    X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
                    X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                    X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
                }

                /**
                 * Shortcut functions to the cipher's object interface.
                 *
                 * @example
                 *
                 *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
                 *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
                 */
                C.Rabbit = StreamCipher._createHelper(Rabbit);
            }());


            /**
             * Counter block mode.
             */
            CryptoJS.mode.CTR = (function () {
                var CTR = CryptoJS.lib.BlockCipherMode.extend();

                var Encryptor = CTR.Encryptor = CTR.extend({
                    processBlock: function (words, offset) {
                        // Shortcuts
                        var cipher = this._cipher
                        var blockSize = cipher.blockSize;
                        var iv = this._iv;
                        var counter = this._counter;

                        // Generate keystream
                        if (iv) {
                            counter = this._counter = iv.slice(0);

                            // Remove IV for subsequent blocks
                            this._iv = undefined;
                        }
                        var keystream = counter.slice(0);
                        cipher.encryptBlock(keystream, 0);

                        // Increment counter
                        counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

                        // Encrypt
                        for (var i = 0; i < blockSize; i++) {
                            words[offset + i] ^= keystream[i];
                        }
                    }
                });

                CTR.Decryptor = Encryptor;

                return CTR;
            }());


            (function () {
                // Shortcuts
                var C = CryptoJS;
                var C_lib = C.lib;
                var StreamCipher = C_lib.StreamCipher;
                var C_algo = C.algo;

                // Reusable objects
                var S = [];
                var C_ = [];
                var G = [];

                /**
                 * Rabbit stream cipher algorithm.
                 *
                 * This is a legacy version that neglected to convert the key to little-endian.
                 * This error doesn't affect the cipher's security,
                 * but it does affect its compatibility with other implementations.
                 */
                var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
                    _doReset: function () {
                        // Shortcuts
                        var K = this._key.words;
                        var iv = this.cfg.iv;

                        // Generate initial state values
                        var X = this._X = [
                            K[0], (K[3] << 16) | (K[2] >>> 16),
                            K[1], (K[0] << 16) | (K[3] >>> 16),
                            K[2], (K[1] << 16) | (K[0] >>> 16),
                            K[3], (K[2] << 16) | (K[1] >>> 16)
                        ];

                        // Generate initial counter values
                        var C = this._C = [
                            (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
                            (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
                            (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
                            (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
                        ];

                        // Carry bit
                        this._b = 0;

                        // Iterate the system four times
                        for (var i = 0; i < 4; i++) {
                            nextState.call(this);
                        }

                        // Modify the counters
                        for (var i = 0; i < 8; i++) {
                            C[i] ^= X[(i + 4) & 7];
                        }

                        // IV setup
                        if (iv) {
                            // Shortcuts
                            var IV = iv.words;
                            var IV_0 = IV[0];
                            var IV_1 = IV[1];

                            // Generate four subvectors
                            var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
                            var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
                            var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
                            var i3 = (i2 << 16) | (i0 & 0x0000ffff);

                            // Modify counter values
                            C[0] ^= i0;
                            C[1] ^= i1;
                            C[2] ^= i2;
                            C[3] ^= i3;
                            C[4] ^= i0;
                            C[5] ^= i1;
                            C[6] ^= i2;
                            C[7] ^= i3;

                            // Iterate the system four times
                            for (var i = 0; i < 4; i++) {
                                nextState.call(this);
                            }
                        }
                    },

                    _doProcessBlock: function (M, offset) {
                        // Shortcut
                        var X = this._X;

                        // Iterate the system
                        nextState.call(this);

                        // Generate four keystream words
                        S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
                        S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
                        S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
                        S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

                        for (var i = 0; i < 4; i++) {
                            // Swap endian
                            S[i] = (((S[i] << 8) | (S[i] >>> 24)) & 0x00ff00ff) |
                                (((S[i] << 24) | (S[i] >>> 8)) & 0xff00ff00);

                            // Encrypt
                            M[offset + i] ^= S[i];
                        }
                    },

                    blockSize: 128 / 32,

                    ivSize: 64 / 32
                });

                function nextState() {
                    // Shortcuts
                    var X = this._X;
                    var C = this._C;

                    // Save old counter values
                    for (var i = 0; i < 8; i++) {
                        C_[i] = C[i];
                    }

                    C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
                    C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
                    C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
                    C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
                    C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
                    C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
                    C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
                    C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
                    this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

                    // Calculate the g-values
                    for (var i = 0; i < 8; i++) {
                        var gx = X[i] + C[i];

                        // Construct high and low argument for squaring
                        var ga = gx & 0xffff;
                        var gb = gx >>> 16;

                        // Calculate high and low result of squaring
                        var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
                        var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

                        // High XOR low
                        G[i] = gh ^ gl;
                    }

                    X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
                    X[1] = (G[1] + ((G[0] << 8) | (G[0] >>> 24)) + G[7]) | 0;
                    X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
                    X[3] = (G[3] + ((G[2] << 8) | (G[2] >>> 24)) + G[1]) | 0;
                    X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
                    X[5] = (G[5] + ((G[4] << 8) | (G[4] >>> 24)) + G[3]) | 0;
                    X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
                    X[7] = (G[7] + ((G[6] << 8) | (G[6] >>> 24)) + G[5]) | 0;
                }

                C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
            }());


            /**
             * Zero padding strategy.
             */
            CryptoJS.pad.ZeroPadding = {
                pad: function (data, blockSize) {
                    // Shortcut
                    var blockSizeBytes = blockSize * 4;

                    // Pad
                    data.clamp();
                    data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
                },

                unpad: function (data) {
                    // Shortcut
                    var dataWords = data.words;

                    // Unpad
                    var i = data.sigBytes - 1;
                    while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
                        i--;
                    }
                    data.sigBytes = i + 1;
                }
            };


            return CryptoJS;

        }));</script>
    <script>

        var keySize = 256;
        var iterations = 1000;
        function decrypt(encryptedMsg, pass) {
            var salt = CryptoJS.enc.Hex.parse(encryptedMsg.substr(0, 32));
            var iv = CryptoJS.enc.Hex.parse(encryptedMsg.substr(32, 32))
            var encrypted = encryptedMsg.substring(64);

            var key = CryptoJS.PBKDF2(pass, salt, {
                keySize: keySize / 32,
                iterations: iterations
            });

            var decrypted = CryptoJS.AES.decrypt(encrypted, key, {
                iv: iv,
                padding: CryptoJS.pad.Pkcs7,
                mode: CryptoJS.mode.CBC
            }).toString(CryptoJS.enc.Utf8);
            return decrypted;
        }

        document.getElementById('staticrypt-form').addEventListener('submit', function (e) {
            e.preventDefault();

            var passphrase = document.getElementById('staticrypt-password').value,
                encryptedMsg = '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',
                encryptedHMAC = encryptedMsg.substring(0, 64),
                encryptedHTML = encryptedMsg.substring(64),
                decryptedHMAC = CryptoJS.HmacSHA256(encryptedHTML, CryptoJS.SHA256(passphrase).toString()).toString();

            if (decryptedHMAC !== encryptedHMAC) {
                alert('Incorrect Password!');
                return;
            }

            var plainHTML = decrypt(encryptedHTML, passphrase);

            document.write(plainHTML);
            document.close();
        });
    </script>
</body>
</html>
